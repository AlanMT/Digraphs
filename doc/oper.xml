#############################################################################
##
#W  oper.xml
#Y  Copyright (C) 2014                                  James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="DigraphReverse">
<ManSection>
  <Oper Name="DigraphReverse" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, then this operation returns a digraph
    constructed from <A>digraph</A> by reversing the edges.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ], 
> [ 2, 3, 5 ] ] );
<digraph with 5 vertices, 11 edges>
gap> DigraphReverse(gr);
<digraph with 5 vertices, 11 edges>
gap> OutNeighbours(last);
[ [ 2, 3, 4 ], [ 4, 5 ], [ 1, 2, 5 ], [ 4 ], [ 2, 5 ] ]
gap> gr:=Digraph(rec(nrvertices:=4, source:=[ 1, 1, 1, 2, 3, 3, 4, 4 ], 
> range:=[ 1, 2, 4, 1, 2, 4, 3, 4 ]));
<digraph with 4 vertices, 8 edges>
gap> gr:=DigraphReverse(gr);
<digraph with 4 vertices, 8 edges>
gap> DigraphRange(gr);
[ 1, 2, 1, 3, 4, 1, 3, 4 ]
gap> DigraphSource(gr);
[ 1, 1, 2, 2, 3, 4, 4, 4 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphRelabel">
<ManSection>
  <Oper Name="DigraphRelabel" Arg="digraph, perm"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, and <A>perm</A> is a permutation of
    the vertices of <A>digraph</A>, then this operation returns a digraph
    constructed from <A>digraph</A> by relabelling the vertices according to
    <A>perm</A>. 
    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ], [ 2, 3, 5 ] ] );
<digraph with 5 vertices, 11 edges>
gap> DigraphRelabel(gr, (1,2));
<digraph with 5 vertices, 11 edges>
gap> OutNeighbours(last);
[ [ 2, 3, 5 ], [ 3 ], [ 2 ], [ 2, 1, 4 ], [ 1, 3, 5 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphRemoveLoops">
<ManSection>
  <Oper Name="DigraphRemoveLoops" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, then this operation returns a digraph 
    constructed from <A>digraph</A> by removing all of the loops (edges with
    equal source and range).
    <Example><![CDATA[
gap> gr := Digraph( [ [ 1, 2, 4 ], [ 1, 4 ], [ 3, 4 ], [ 1, 4, 5 ], 
> [ 1, 5 ] ] );
<digraph with 5 vertices, 12 edges>
gap> DigraphRemoveLoops(gr);                 
<digraph with 5 vertices, 8 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphRemoveEdges">
<ManSection>
  <Oper Name="DigraphRemoveEdges" Arg="digraph, edges"/>
  <Returns>A digraph.</Returns>
  <Description>
    If:
    <List>
      <Item>
        <A>digraph</A> is a digraph with no multiple edges, and <A>edges</A> is 
        a list of pairs of vertices of <A>digraph</A>, or
      </Item>
      <Item>
        <A>digraph</A> is any digraph and <A>edges</A> is a list of indices of 
        edges of <A>digraph</A>,
      </Item>
    </List>
    
    then this operation returns a digraph constructed from <A>digraph</A> by 
    removing all of the edges specified by <A>edges</A>. <P/>

    <Example><![CDATA[
gap> cycle := function(n)
>  local record, i;
>  record := rec( vertices := [ 1 .. n ], source := [  ], range := [  ] );
>  for i in [ 0 .. n - 1 ] do 
>    Add(record.source, i mod Length(record.vertices) + 1);
>    Add(record.range, (i + 1) mod Length(record.vertices) +1);
>  od;
>  return Digraph(record);
> end;;
gap> gr := cycle(250000);
<digraph with 250000 vertices, 250000 edges>
gap> gr := DigraphRemoveEdges(gr, [ [250000, 1] ]);
<digraph with 250000 vertices, 249999 edges>
gap> gr := DigraphRemoveEdges(gr, [ 10 ]);
<digraph with 250000 vertices, 249998 edges>]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphReflexiveTransitiveClosure">
<ManSection>
  <Oper Name="DigraphReflexiveTransitiveClosure" Arg="digraph"/>
  <Oper Name="DigraphTransitiveClosure" Arg="digraph"/>
  <Returns>A digraph, or <K>fail</K>.</Returns>
  <Description>
    If <A>digraph</A> is a digraph with no multiple edges, these functions 
    return the (reflexive) transitive closure of the <A>digraph</A>. If 
    <A>digraph</A> is a multidigraph, then this function returns <K>fail</K>. 
<P/>

    A digraph is <E>reflexive</E> if there is a loop at every vertex, and it is 
    <E>transitive</E> if whenever <C>[ i, j ]</C> and <C>[ j, k ]</C> are edges,
    <C>[ i, k ]</C> is also an edge. The <E>(reflexive) transitive closure</E> 
    of a digraph <A>digraph</A> is the least (reflexive and) transitive digraph 
    containing <A>digraph</A>. <P/>

    The methods used in this operation have complexity <M>O(n^3)</M>, where 
    <M>n</M> is the number of vertices of the digraph. <P/>

    <Example><![CDATA[
gap> gr:=Digraph( [ [ 4, 6 ], [ 1, 3 ], [ ], [ 5 ], [ ], [ 7, 8, 9 ], 
> [ ], [ ], [ ] ] );;
gap> DigraphTransitiveClosure(gr);
<digraph with 9 vertices, 18 edges>
gap> OutNeighbours(last);
[ [ 4, 5, 6, 7, 8, 9 ], [ 1, 3, 4, 5, 6, 7, 8, 9 ], [  ], [ 5 ], 
  [  ], [ 7, 8, 9 ], [  ], [  ], [  ] ]
gap> DigraphReflexiveTransitiveClosure(gr);  
<digraph with 9 vertices, 27 edges>
gap> OutNeighbours(last);
[ [ 1, 4, 5, 6, 7, 8, 9 ], [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 3 ], 
  [ 4, 5 ], [ 5 ], [ 6, 7, 8, 9 ], [ 7 ], [ 8 ], [ 9 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="InducedSubdigraph">
<ManSection>
  <Oper Name="InducedSubdigraph" Arg="digraph, verts"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, and <A>verts</A> is a subset of the 
    vertices of <A>digraph</A>, then this operation returns a digraph 
    constructed from <A>digraph</A> by retaining precisely those vertices in 
    <A>verts</A>, and those edges whose source and range are both contained in
    <A>verts</A>. <P/>
    Note that the vertices of the resultant digraph will labelled 
    <C>[ 1 .. Length(verts) ]</C>. <P/>
    <Example><![CDATA[
gap> gr := Digraph( [ [ 1, 1, 2, 3, 4, 4 ], [ 1, 3, 4 ], [ 3, 1 ], [ 1, 1 ] ] ); 
<multidigraph with 4 vertices, 13 edges>
gap> InducedSubdigraph( gr, [ 1, 3, 4 ] );                 
<multidigraph with 3 vertices, 9 edges>
gap> DigraphVertices(last);
[ 1 .. 3 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="InNeighboursOfVertex">
<ManSection>
  <Oper Name="InNeighboursOfVertex" Arg="digraph, vertex"/>
  <Returns>A list of in-neighbours of a given vertex</Returns>
  <Description>
    Returns the list <C>inn</C> such that a vertex <C>i</C> is in <C>inn</C>
    whenever there is an edge from <C>i</C> to <A>vertex</A> in <A>digraph</A>.
    <Example><![CDATA[
gap> gr := 
> Digraph( [ [ 2, 2, 3 ], [ 1, 3, 4 ], [ 2, 2, 3 ], [ 1, 1, 2, 2, 1, 2, 2 ] ] );
<multidigraph with 4 vertices, 16 edges>
gap> InNeighboursOfVertex(gr, 1);
[ 2, 4, 4, 4 ]
gap> InNeighboursOfVertex(gr, 2);
[ 1, 1, 3, 3, 4, 4, 4, 4 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="OutNeighboursOfVertex">
<ManSection>
  <Oper Name="OutNeighboursOfVertex" Arg="digraph, vertex"/>
  <Returns>A list of out-neighbours of a given vertex</Returns>
  <Description>
    Returns the list <C>out</C> such that a vertex <C>i</C> is in <C>out</C>
    whenever there is an edge from <A>vertex</A> to <C>i</C> in <A>digraph</A>.
    <Example><![CDATA[
gap> gr := 
> Digraph( [ [ 2, 2, 3 ], [ 1, 3, 4 ], [ 2, 2, 3 ], [ 1, 1, 2, 2, 1, 2, 2 ] ] );
<multidigraph with 4 vertices, 16 edges>
gap> OutNeighboursOfVertex(gr,1);
[ 2, 2, 3 ]
gap> OutNeighboursOfVertex(gr,3);
[ 2, 2, 3 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>
