#############################################################################
##
#W  oper.xml
#Y  Copyright (C) 2014                                  James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="DigraphVertexNames">
<ManSection>
  <Oper Name="DigraphVertexNames" Arg="digraph"/>
  <Oper Name="SetDigraphVertexNames" Arg="digraph, list"/>
  <Returns>A list of names of a vertices.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, then the first operation returns the names of
    the vertices in <A>digraph</A>. The second operation can be used to set the
    names of all of the vertices in <A>digraph</A> to the list of arbitrary &GAP;
    objects <A>list</A>. <P/>

    The name of vertex can be changed an arbitrary number of times. If no name
    has be set for the vertex <A>i</A>, then <C>DigraphVertexNames</C> just
    assumses that the name is <C>i</C>. <P/>

    If <A>digraph</A> is a digraph created from a record with a component
    <C>vertices</C>, then the names of the vertices are set to the value of this
    component.<P/>

    Induced subdigraphs inherit their names from their parents. 

    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ], 
> [ 2, 3, 5 ] ] );
<digraph with 5 vertices, 11 edges>
gap> DigraphVertexNames(gr);
[ 1 .. 5 ]
gap> gr:=Digraph(rec(vertices:=["a", "b", "c"], range:=[], source:=[]));
<digraph with 3 vertices, 0 edges>
gap> DigraphVertexNames(gr);
[ "a", "b", "c" ]
gap> SetDigraphVertexName(gr, 2, "d");
gap> DigraphVertexNames(gr);
[ "a", "d", "c" ]
gap> gr:=InducedSubdigraph(gr, [1,3]);
<digraph with 2 vertices, 0 edges>
gap> DigraphVertexNames(gr);
[ "a", "c" ]]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphVertexName">
<ManSection>
  <Oper Name="DigraphVertexName" Arg="digraph, i"/>
  <Oper Name="SetDigraphVertexName" Arg="digraph, i, obj"/>
  <Returns>The name of a vertex.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, then the first operation returns the name of
    the vertex <A>i</A>. The second operation can be used to set the name of the
    vertex <A>i</A> in <A>digraph</A> to the arbitrary &GAP; object <A>obj</A>. <P/>

    The name of vertex can be changed an arbitrary number of times. If no name
    has be set for the vertex <A>i</A>, then <C>DigraphVertexName</C> just
    returns <C>i</C>. <P/>

    If <A>digraph</A> is a digraph created from a record with a component
    <C>vertices</C>, then the names of the vertices are set to the value of this
    component.<P/>

    Induced subdigraphs inherit their names from their parents. 

    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ], 
> [ 2, 3, 5 ] ] );
<digraph with 5 vertices, 11 edges>
gap> DigraphVertexName(gr, 3);
3
gap> gr:=Digraph(rec(vertices:=["a", "b", "c"], range:=[], source:=[]));
<digraph with 3 vertices, 0 edges>
gap> DigraphVertexName(gr, 2);
"b"
gap> SetDigraphVertexName(gr, 2, "d");
gap> DigraphVertexName(gr, 2);
"d"
gap> gr:=InducedSubdigraph(gr, [1,2]);
<digraph with 2 vertices, 0 edges>
gap> DigraphVertexName(gr, 2);
"d"]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphReverse">
<ManSection>
  <Oper Name="DigraphReverse" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, then this operation returns a digraph
    constructed from <A>digraph</A> by reversing the edges.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ], 
> [ 2, 3, 5 ] ] );
<digraph with 5 vertices, 11 edges>
gap> DigraphReverse(gr);
<digraph with 5 vertices, 11 edges>
gap> OutNeighbours(last);
[ [ 2, 3, 4 ], [ 4, 5 ], [ 1, 2, 5 ], [ 4 ], [ 2, 5 ] ]
gap> gr:=Digraph(rec(nrvertices:=4, source:=[ 1, 1, 1, 2, 3, 3, 4, 4 ], 
> range:=[ 1, 2, 4, 1, 2, 4, 3, 4 ]));
<digraph with 4 vertices, 8 edges>
gap> gr:=DigraphReverse(gr);
<digraph with 4 vertices, 8 edges>
gap> DigraphRange(gr);
[ 1, 2, 1, 3, 4, 1, 3, 4 ]
gap> DigraphSource(gr);
[ 1, 1, 2, 2, 3, 4, 4, 4 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="OnDigraphs">
<ManSection>
  <Oper Name="OnDigraphs" Arg="digraph, perm"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, and <A>perm</A> is a permutation of
    the vertices of <A>digraph</A>, then this operation returns a digraph
    constructed by relabelling the vertices of <A>digraph</A> according to
    <A>perm</A>. <P/>
    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ], 
> [ 2, 3, 5 ] ] );
<digraph with 5 vertices, 11 edges>
gap> OnDigraphs(gr, (1,2));
<digraph with 5 vertices, 11 edges>
gap> OutNeighbours(last);
[ [ 2, 3, 5 ], [ 3 ], [ 2 ], [ 2, 1, 4 ], [ 1, 3, 5 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphRemoveLoops">
<ManSection>
  <Oper Name="DigraphRemoveLoops" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, then this operation returns a digraph 
    constructed from <A>digraph</A> by removing all of the loops (edges with
    equal source and range).
    <Example><![CDATA[
gap> gr := Digraph( [ [ 1, 2, 4 ], [ 1, 4 ], [ 3, 4 ], [ 1, 4, 5 ], 
> [ 1, 5 ] ] );
<digraph with 5 vertices, 12 edges>
gap> DigraphRemoveLoops(gr);               
<digraph with 5 vertices, 8 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphAddEdges">
<ManSection>
  <Oper Name="DigraphAddEdges" Arg="digraph, edges"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>edges</A> is a list of pairs of vertices of <A>digraph</A>,
    then this operation returns a new digraph constructed from <A>digraph</A> 
    by adding the edges specified by <A>edges</A>. <P/>
  
    If an edge is included multiple times in <A>edges</A>, then it will be
    added multiple times. If the list <A>edges</A> is empty, then the object
    <A>digraph</A> will be returned. <P/>

    <Example><![CDATA[
gap> func := function(n)
>  local record, i;
>  record := rec( vertices := [ 1 .. n ], source := [  ], range := [  ] );
>  for i in [ 1 .. n - 2 ] do 
>    Add(record.source, i);
>    Add(record.range, i + 1);
>  od;
>  return Digraph(record);
> end;;
gap> gr := func(1024);
<digraph with 1024 vertices, 1022 edges>
gap> gr := DigraphAddEdges(gr,
> [ [ 1023, 1024 ], [ 1, 1024 ], [ 1023, 1024 ], [ 1024, 1 ] ] );
<multidigraph with 1024 vertices, 1026 edges>]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphRemoveEdges">
<ManSection>
  <Oper Name="DigraphRemoveEdges" Arg="digraph, edges"/>
  <Returns>A digraph.</Returns>
  <Description>
    If:
    <List>
      <Item>
        <A>digraph</A> is a digraph with no multiple edges, and <A>edges</A> is 
        a list of pairs of vertices of <A>digraph</A>, or
      </Item>
      <Item>
        <A>digraph</A> is any digraph and <A>edges</A> is a list of indices of 
        edges of <A>digraph</A>,
      </Item>
    </List>
    
    then this operation returns a digraph constructed from <A>digraph</A> by 
    removing all of the edges specified by <A>edges</A>. <P/>

    <Example><![CDATA[
gap> cycle := function(n)
>  local record, i;
>  record := rec( vertices := [ 1 .. n ], source := [  ], range := [  ] );
>  for i in [ 0 .. n - 1 ] do 
>    Add(record.source, i mod Length(record.vertices) + 1);
>    Add(record.range, (i + 1) mod Length(record.vertices) +1);
>  od;
>  return Digraph(record);
> end;;
gap> gr := cycle(250000);
<digraph with 250000 vertices, 250000 edges>
gap> gr := DigraphRemoveEdges(gr, [ [250000, 1] ]);
<digraph with 250000 vertices, 249999 edges>
gap> gr := DigraphRemoveEdges(gr, [ 10 ]);
<digraph with 250000 vertices, 249998 edges>]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphReflexiveTransitiveClosure">
<ManSection>
  <Oper Name="DigraphReflexiveTransitiveClosure" Arg="digraph"/>
  <Oper Name="DigraphTransitiveClosure" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph with no multiple edges, these functions 
    return the (reflexive) transitive closure of the <A>digraph</A>. <P/>

    A digraph is <E>reflexive</E> if there is a loop at every vertex, and it is 
    <E>transitive</E> if whenever <C>[ i, j ]</C> and <C>[ j, k ]</C> are edges,
    <C>[ i, k ]</C> is also an edge. The <E>(reflexive) transitive closure</E> 
    of a digraph <A>digraph</A> is the least (reflexive and) transitive digraph 
    containing <A>digraph</A>. <P/>

    The methods used in this operation have complexity <M>O(n^3)</M>, where 
    <M>n</M> is the number of vertices of the digraph. <P/>

    <Example><![CDATA[
gap> gr:=Digraph( [ [ 4, 6 ], [ 1, 3 ], [ ], [ 5 ], [ ], [ 7, 8, 9 ], 
> [ ], [ ], [ ] ] );;
gap> DigraphTransitiveClosure(gr);
<digraph with 9 vertices, 18 edges>
gap> OutNeighbours(last);
[ [ 4, 5, 6, 7, 8, 9 ], [ 1, 3, 4, 5, 6, 7, 8, 9 ], [  ], [ 5 ], 
  [  ], [ 7, 8, 9 ], [  ], [  ], [  ] ]
gap> DigraphReflexiveTransitiveClosure(gr);  
<digraph with 9 vertices, 27 edges>
gap> OutNeighbours(last);
[ [ 1, 4, 5, 6, 7, 8, 9 ], [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 3 ], 
  [ 4, 5 ], [ 5 ], [ 6, 7, 8, 9 ], [ 7 ], [ 8 ], [ 9 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="InducedSubdigraph">
<ManSection>
  <Oper Name="InducedSubdigraph" Arg="digraph, verts"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, and <A>verts</A> is a subset of the 
    vertices of <A>digraph</A>, then this operation returns a digraph 
    constructed from <A>digraph</A> by retaining precisely those vertices in 
    <A>verts</A>, and those edges whose source and range are both contained in
    <A>verts</A>. <P/>
    The vertices of the induced subdigraph are 
    <C>[ 1 .. Length(verts) ]</C> but the original names can be accessed via 
    <Ref Oper="DigraphVertexNames"/>.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 1, 1, 2, 3, 4, 4 ], [ 1, 3, 4 ], [ 3, 1 ], 
> [ 1, 1 ] ] ); 
<multidigraph with 4 vertices, 13 edges>
gap> InducedSubdigraph( gr, [ 1, 3, 4 ] );                 
<multidigraph with 3 vertices, 9 edges>
gap> DigraphVertices(last);
[ 1 .. 3 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="OutDegreeOfVertex">
<ManSection>
  <Oper Name="OutDegreeOfVertex" Arg="digraph, vertex"/>
  <Returns>The non-negative integer.</Returns>
  <Description>
    Returns the out-degree of <A>vertex</A> in <A>digraph</A>; specifically,
    the number of edges in <A>digraph</A> whose source is <A>vertex</A>.
    <P/>
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 2, 1 ], [ 1, 4 ], [ 2, 2, 4, 2 ], 
> [ 1, 1, 2, 2, 1, 2, 2 ] ] );
<multidigraph with 4 vertices, 16 edges>
gap> OutDegreeOfVertex(gr, 1);
3
gap> OutDegreeOfVertex(gr, 2);
2
gap> OutDegreeOfVertex(gr, 3);
4
gap> OutDegreeOfVertex(gr, 4);
7
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="OutNeighboursOfVertex">
<ManSection>
  <Oper Name="OutNeighboursOfVertex" Arg="digraph, vertex"/>
  <Returns>A list of positive integers.</Returns>
  <Description>
    Returns the list <C>out</C> such that a vertex <C>i</C> is in <C>out</C>
    whenever there is an edge from <A>vertex</A> to <C>i</C> in <A>digraph</A>.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 2, 3 ], [ 1, 3, 4 ], [ 2, 2, 3 ], 
> [ 1, 1, 2, 2, 1, 2, 2 ] ] );
<multidigraph with 4 vertices, 16 edges>
gap> OutNeighboursOfVertex(gr, 1);
[ 2, 2, 3 ]
gap> OutNeighboursOfVertex(gr, 3);
[ 2, 2, 3 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="InDegreeOfVertex">
<ManSection>
  <Oper Name="InDegreeOfVertex" Arg="digraph, vertex"/>
  <Returns>A non-negative integer.</Returns>
  <Description>
    Returns the in-degree of <A>vertex</A> in <A>digraph</A>; specifically,
    the number of edges in <A>digraph</A> whose range is <A>vertex</A>.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 2, 1 ], [ 1, 4 ], [ 2, 2, 4, 2 ], 
> [ 1, 1, 2, 2, 1, 2, 2 ] ] );
<multidigraph with 4 vertices, 16 edges>
gap> InDegreeOfVertex(gr, 1);
5
gap> InDegreeOfVertex(gr, 2);
9
gap> InDegreeOfVertex(gr, 3);
0
gap> InDegreeOfVertex(gr, 4);
2
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="InNeighboursOfVertex">
<ManSection>
  <Oper Name="InNeighboursOfVertex" Arg="digraph, vertex"/>
  <Returns>A list of postitive integers.</Returns>
  <Description>
    Returns the list <C>inn</C> such that a vertex <C>i</C> is in <C>inn</C>
    whenever there is an edge from <C>i</C> to <A>vertex</A> in <A>digraph</A>.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 2, 3 ], [ 1, 3, 4 ], [ 2, 2, 3 ], 
> [ 1, 1, 2, 2, 1, 2, 2 ] ] );
<multidigraph with 4 vertices, 16 edges>
gap> InNeighboursOfVertex(gr, 1);
[ 2, 4, 4, 4 ]
gap> InNeighboursOfVertex(gr, 2);
[ 1, 1, 3, 3, 4, 4, 4, 4 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphInEdges">
<ManSection>
  <Oper Name="DigraphInEdges" Arg="digraph, vertex"/>
  <Returns>A list of edges.</Returns>
  <Description>
    <C>DigraphInEdges</C> returns the list of all edges of <A>digraph</A>
    which have <A>vertex</A> as their range. 
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 2 ], [ 3, 3 ], [ 4, 4 ], [ 1, 1 ] ] );
<multidigraph with 4 vertices, 8 edges>
gap> DigraphInEdges(gr, 2);
[ [ 1, 2 ], [ 1, 2 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphOutEdges">
<ManSection>
  <Oper Name="DigraphOutEdges" Arg="digraph, vertex"/>
  <Returns>A list of edges.</Returns>
  <Description>
    <C>DigraphOutEdges</C> returns the list of all edges of <A>digraph</A>
    which have <A>vertex</A> as their source.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 2 ], [ 3, 3 ], [ 4, 4 ], [ 1, 1 ] ] );
<multidigraph with 4 vertices, 8 edges>
gap> DigraphOutEdges(gr, 2);
[ [ 2, 3 ], [ 2, 3 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphStronglyConnectedComponent">
<ManSection>
  <Oper Name="DigraphStronglyConnectedComponent" Arg="digraph, vertex"/>
  <Returns>A list of vertices.</Returns>
  <Description>
    <C>DigraphStronglyConnectedComponent</C> returns the strongly connected
    component of <A>vertex</A> in <A>digraph</A>.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 2 ], [ 1, 2 ], [ 3 ] ] );
<digraph with 4 vertices, 5 edges>
gap> DigraphStronglyConnectedComponent(gr, 3);
[ 1, 3 ]
gap> DigraphStronglyConnectedComponent(gr, 2);
[ 2 ]
gap> DigraphStronglyConnectedComponent(gr, 4);
[ 4 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="QuotientDigraph">
<ManSection>
  <Oper Name="QuotientDigraph" Arg="digraph, p"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph with at least one vertex, and <A>p</A> is a 
    partition of the vertices of <A>digraph</A>, then this operation returns a
    new digraph constructed by amalgamating all vertices of <A>digraph</A> 
    which lie in the same part of <A>p</A>. <P/>

    A partition of the vertices of <A>digraph</A> is a list of non-empty 
    disjoint lists, such that the concatenation of all the sub-lists is
    equal to the vertex set of <A>digraph</A>. In particular, each vertex
    must appear in precisely one sub-list. <P/>

    The vertices of <A>digraph</A> in part <C>i</C> of <A>p</A> will become 
    vertex <C>i</C> in the quotient, and an edge of <A>digraph</A> with 
    source (range) vertex in part <C>i</C> will have source (range) <C>i</C> in 
    the quotient. <P/>
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 1 ], [ 4 ], [ 1 ], [ 1, 3, 4 ] ] );
<digraph with 4 vertices, 7 edges>
gap> DigraphVertices(gr);
[ 1 .. 4 ]
gap> DigraphEdges(gr);
[ [ 1, 2 ], [ 1, 1 ], [ 2, 4 ], [ 3, 1 ], [ 4, 1 ], [ 4, 3 ], 
  [ 4, 4 ] ]
gap> p := [ [ 1 ], [ 2, 4 ], [ 3 ] ];
[ [ 1 ], [ 2, 4 ], [ 3 ] ]
gap> qr := QuotientDigraph( gr, p );
<multidigraph with 3 vertices, 7 edges>
gap> DigraphVertices(qr);
[ 1 .. 3 ]
gap> DigraphEdges(qr);
[ [ 1, 2 ], [ 1, 1 ], [ 2, 2 ], [ 2, 1 ], [ 2, 3 ], [ 2, 2 ], 
  [ 3, 1 ] ]
gap> p2 := [ [ 1 ], [ 2 ], [ 3 ], [ 4 ] ];
[ [ 1 ], [ 2 ], [ 3 ], [ 4 ] ]
gap> QuotientDigraph(gr, p2) = gr;
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsDigraphEdge">
<ManSection>
  <Oper Name="IsDigraphEdge" Arg="digraph, list"/>
  <Returns> <K>true</K> or <K>false</K>.</Returns>
  <Description>
    Returns true if and only if <A>list</A> is a list of size 2 such that
    <A>list[1]</A> is a source and <A>list[2]</A> is a range of an edge
    in <A>digraph</A>.
<Example><![CDATA[
gap> gr := Digraph(rec(nrvertices := 6, source := [1,1,2,4,6],
> range:=[2,2,6,3,1]));
<multidigraph with 6 vertices, 5 edges>
gap> IsDigraphEdge(gr, [1,1]);
false
gap> IsDigraphEdge(gr, [1,2]);
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>
