#############################################################################
##
#W  oper.xml
#Y  Copyright (C) 2014                                  James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="DigraphVertexNames">
<ManSection>
  <Oper Name="DigraphVertexNames" Arg="digraph"/>
  <Oper Name="SetDigraphVertexNames" Arg="digraph, list"/>
  <Returns>A list of names of a vertices.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, then the first operation returns the names 
    of the vertices in <A>digraph</A>. The second operation can be used to set 
    the names of all of the vertices in <A>digraph</A> to the list of arbitrary 
    &GAP; objects <A>list</A>. <P/>

    The name of vertex can be changed an arbitrary number of times. If no name
    has be set for the vertex <A>i</A>, then <C>DigraphVertexNames</C> just
    assumses that the name is <C>i</C>. <P/>

    If <A>digraph</A> is a digraph created from a record with a component
    <C>vertices</C>, then the names of the vertices are set to the value of this
    component.<P/>

    Induced subdigraphs inherit their names from their parents. 

    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ], 
> [ 2, 3, 5 ] ] );
<digraph with 5 vertices, 11 edges>
gap> DigraphVertexNames(gr);
[ 1 .. 5 ]
gap> gr := Digraph( rec( vertices := [ "a", "b", "c" ],
> range := [  ], source := [  ] ) );
<digraph with 3 vertices, 0 edges>
gap> DigraphVertexNames(gr);
[ "a", "b", "c" ]
gap> SetDigraphVertexName(gr, 2, "d");
gap> DigraphVertexNames(gr);
[ "a", "d", "c" ]
gap> gr:=InducedSubdigraph(gr, [ 1, 3 ]);
<digraph with 2 vertices, 0 edges>
gap> DigraphVertexNames(gr);
[ "a", "c" ]]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphVertexName">
<ManSection>
  <Oper Name="DigraphVertexName" Arg="digraph, i"/>
  <Oper Name="SetDigraphVertexName" Arg="digraph, i, obj"/>
  <Returns>The name of a vertex.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, then the first operation returns the name of
    the vertex <A>i</A>. The second operation can be used to set the name of the
    vertex <A>i</A> in <A>digraph</A> to the arbitrary &GAP; object <A>obj</A>. 
    <P/>

    The name of vertex can be changed an arbitrary number of times. If no name
    has be set for the vertex <A>i</A>, then <C>DigraphVertexName</C> just
    returns <C>i</C>. <P/>

    If <A>digraph</A> is a digraph created from a record with a component
    <C>vertices</C>, then the names of the vertices are set to the value of this
    component.<P/>

    Induced subdigraphs inherit their names from their parents. 

    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ], 
> [ 2, 3, 5 ] ] );
<digraph with 5 vertices, 11 edges>
gap> DigraphVertexName(gr, 3);
3
gap> gr := Digraph( rec( vertices := [ "a", "b", "c" ],
> range := [  ], source := [  ] ) );
<digraph with 3 vertices, 0 edges>
gap> DigraphVertexName(gr, 2);
"b"
gap> SetDigraphVertexName(gr, 2, "d");
gap> DigraphVertexName(gr, 2);
"d"
gap> gr:=InducedSubdigraph(gr, [ 1, 2 ]);
<digraph with 2 vertices, 0 edges>
gap> DigraphVertexName(gr, 2);
"d"]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphReverse">
<ManSection>
  <Oper Name="DigraphReverse" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, then this operation returns a digraph
    constructed from <A>digraph</A> by reversing the edges.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ], 
> [ 2, 3, 5 ] ] );
<digraph with 5 vertices, 11 edges>
gap> DigraphReverse(gr);
<digraph with 5 vertices, 11 edges>
gap> OutNeighbours(last);
[ [ 2, 3, 4 ], [ 4, 5 ], [ 1, 2, 5 ], [ 4 ], [ 2, 5 ] ]
gap> gr := Digraph( rec( nrvertices := 4,
> source := [ 1, 1, 1, 2, 3, 3, 4, 4 ], 
> range := [ 1, 2, 4, 1, 2, 4, 3, 4 ] ) );
<digraph with 4 vertices, 8 edges>
gap> gr:=DigraphReverse(gr);
<digraph with 4 vertices, 8 edges>
gap> DigraphRange(gr);
[ 1, 2, 1, 3, 4, 1, 3, 4 ]
gap> DigraphSource(gr);
[ 1, 1, 2, 2, 3, 4, 4, 4 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphReverseEdges">
<ManSection>
  <Oper Name="DigraphReverseEdges" Arg="digraph, edges"/>
  <Oper Name="DigraphReverseEdge" Arg="digraph, edge"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> does not have any multiple edges and <A>edges</A>
    is a list of edges given either as list of size two (the first entry
    corresponding to the source and the second to the range of the
    vertex) or as an index in the list <Ref Oper = "DigraphEdges"/>, then
    <C>DigraphReverseEdges</C> return a digraph with the
    direction of <A>edges</A> reversed. <P/>

    Note that, even though <A>digraph</A> can not have multiple edges the
    outputmight. Also if the argument <A>edges</A> is an empty list, the
    digraph itself is returned.<P/>
    <Example><![CDATA[
gap> gr := Digraph(rec(nrvertices := 21, source := [1,1,1,5,7,9,11,21],
> range := [7,2,8,21,19,1,2,1]));
<digraph with 21 vertices, 8 edges>
gap> gr2 := DigraphReverseEdges(gr, [1,2,3]);
<digraph with 21 vertices, 8 edges>
gap> gr = DigraphReverseEdges(gr2, [[7,1], [2,1], [8,1]]);
true
gap> gr2 := DigraphReverseEdge(gr, 4);
<digraph with 21 vertices, 8 edges>
gap> gr2 = DigraphReverseEdge(gr, [5, 21]);
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="OnDigraphs">
<ManSection>
  <Oper Name="OnDigraphs" Arg="digraph, perm"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, and <A>perm</A> is a permutation of
    the vertices of <A>digraph</A>, then this operation returns a digraph
    constructed by relabelling the vertices of <A>digraph</A> according to
    <A>perm</A>. <P/>
    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ], 
> [ 2, 3, 5 ] ] );
<digraph with 5 vertices, 11 edges>
gap> OnDigraphs(gr, (1,2));
<digraph with 5 vertices, 11 edges>
gap> OutNeighbours(last);
[ [ 2, 3, 5 ], [ 3 ], [ 2 ], [ 2, 1, 4 ], [ 1, 3, 5 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphRemoveLoops">
<ManSection>
  <Oper Name="DigraphRemoveLoops" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, then this operation returns a digraph 
    constructed from <A>digraph</A> by removing all of the loops (edges with
    equal source and range).
    <Example><![CDATA[
gap> gr := Digraph( [ [ 1, 2, 4 ], [ 1, 4 ], [ 3, 4 ], [ 1, 4, 5 ], 
> [ 1, 5 ] ] );
<digraph with 5 vertices, 12 edges>
gap> DigraphRemoveLoops(gr);               
<digraph with 5 vertices, 8 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphAddVertex">
<ManSection>
  <Oper Name="DigraphAddVertex" Arg="digraph[, name ]"/>
  <Returns>A digraph.</Returns>
  <Description>
    The operation returns a new digraph constructed from <A>digraph</A> by
    adding a single new vertex. If the optional second argument <A>name</A> is
    an arbitrary &GAP; object, then the new vertex will be named <A>name</A>.
    <P/>
    <Example><![CDATA[
gap> gr := CompleteDigraph(3);
<digraph with 3 vertices, 9 edges>
gap> new := DigraphAddVertex(gr);
<digraph with 4 vertices, 9 edges>
gap> DigraphVertices(new);
[ 1 .. 4 ]
gap> new := DigraphAddVertex(gr, Group( [(1,2)] ));
<digraph with 4 vertices, 9 edges>
gap> DigraphVertexNames(new);
[ 1, 2, 3, Group([ (1,2) ]) ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphAddVertices">
<ManSection>
  <Oper Name="DigraphAddVertices" Arg="digraph, m[, names ]"/>
  <Returns>A digraph.</Returns>
  <Description>
    For a non-negative integer <A>m</A>, this operation returns a new digraph 
    constructed from <A>digraph</A> by adding <A>m</A> new vertices. If the
    optional third argument <A>names</A> is a list of length <A>m</A> consisting
    of arbitrary &GAP; objects, then the new vertices will be named according 
    to this list. <P/>
    <Example><![CDATA[
gap> gr := CompleteDigraph(3);
<digraph with 3 vertices, 9 edges>
gap> new := DigraphAddVertices(gr, 3);
<digraph with 6 vertices, 9 edges>
gap> DigraphVertices(new);
[ 1 .. 6 ]
gap> new := DigraphAddVertices(gr, 2, [ Group( [(1,2)] ), "d" ] );
<digraph with 5 vertices, 9 edges>
gap> DigraphVertexNames(new);
[ 1, 2, 3, Group([ (1,2) ]), "d" ]
gap> DigraphAddVertices(gr, 0) = gr;
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphRemoveVertex">
<ManSection>
  <Oper Name="DigraphRemoveVertex" Arg="digraph, v"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>v</A> is a vertex of <A>digraph</A>, then this operation returns a 
    new digraph constructed from <A>digraph</A> by removing vertex <A>v</A>,
    along with any edges which have source or range equal to <A>v</A>. <P/>

    If <A>digraph</A> has <C>n</C> vertices, then the vertices of the new
    digraph are <C>[ 1 .. n - 1 ]</C>, but the original names can be 
    accessed via <Ref Oper="DigraphVertexNames"/>.

    <Example><![CDATA[
gap> gr := Digraph( rec( vertices := [ "a", "b", "c" ],
> source := [ "a", "a", "b", "c", "c" ],
> range  := [ "b", "c", "a", "a", "c" ] ) );
<digraph with 3 vertices, 5 edges>
gap> DigraphVertexNames(gr);
[ "a", "b", "c" ]
gap> DigraphEdges(gr);
[ [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 3, 1 ], [ 3, 3 ] ]
gap> new := DigraphRemoveVertex(gr, 2);
<digraph with 2 vertices, 3 edges>
gap> DigraphVertexNames(new);
[ "a", "c" ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphRemoveVertices">
<ManSection>
  <Oper Name="DigraphRemoveVertices " Arg="digraph, verts"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>verts</A> is a (possibly empty) duplicate-free list of vertices of 
    <A>digraph</A>, then this operation returns a new digraph constructed from 
    <A>digraph</A> by removing every vertex in <A>verts</A>, along with any 
    edges which have source or range is an element of <A>verts</A>. <P/>

    If <A>digraph</A> has <C>n</C> vertices, then the vertices of the new
    digraph are <C>[ 1 .. n - Length(</C><A> verts </A><C>) ]</C>, but the 
    original names can be accessed via <Ref Oper="DigraphVertexNames"/>. <P/>

    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ],
> [ 2, 3, 5 ] ] );
<digraph with 5 vertices, 11 edges>
gap> SetDigraphVertexNames( gr, [ "a", "b", "c", "d", "e" ] );
gap> new := DigraphRemoveVertices(gr, [ 2, 4 ] );
<digraph with 3 vertices, 4 edges>
gap> DigraphVertexNames(new);
[ "a", "c", "e" ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>


<#GAPDoc Label="DigraphAddEdge">
<ManSection>
  <Oper Name="DigraphAddEdge" Arg="digraph, edge"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>edge</A> is a pairs of vertices of <A>digraph</A>,
    then this operation returns a new digraph constructed from <A>digraph</A> 
    by adding a new edge with source <A>edge</A><C>[1]</C> and range 
    <A>edge</A><C>[2]</C>.
    <P/>

    <Example><![CDATA[
gap> gr1 := Digraph( [ [ 2 ], [ 3 ], [ ] ] );
<digraph with 3 vertices, 2 edges>
gap> DigraphEdges(gr1);
[ [ 1, 2 ], [ 2, 3 ] ]
gap> gr2 := DigraphAddEdge(gr1, [ 3, 1 ]);
<digraph with 3 vertices, 3 edges>
gap> DigraphEdges(gr2);
[ [ 1, 2 ], [ 2, 3 ], [ 3, 1 ] ]
gap> gr3 := DigraphAddEdge(gr2, [ 2, 3 ] );
<multidigraph with 3 vertices, 4 edges>
gap> DigraphEdges(gr3);
[ [ 1, 2 ], [ 2, 3 ], [ 2, 3 ], [ 3, 1 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphAddEdges">
<ManSection>
  <Oper Name="DigraphAddEdges" Arg="digraph, edges"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>edges</A> is a (possibly empty) list of pairs of vertices of 
    <A>digraph</A>, then this operation returns a new digraph constructed from 
    <A>digraph</A> by adding the edges specified by <A>edges</A>.
    More precisely, for each <C>i</C>, a new edge will be added with source 
    <A>edges</A><C>[i][1]</C> and range <A>edges</A><C>[i][2]</C>.
    <P/>
    
    If an edge is included multiple times in <A>edges</A>, then it will be
    added multiple times. <P/> 

    <Example><![CDATA[
gap> func := function(n)
>  local record, i;
>  record := rec( nrvertices := n, source := [  ], range := [  ] );
>  for i in [ 1 .. n - 2 ] do 
>    Add(record.source, i);
>    Add(record.range, i + 1);
>  od;
>  return Digraph(record);
> end;;
gap> gr := func(1024);
<digraph with 1024 vertices, 1022 edges>
gap> gr := DigraphAddEdges(gr,
> [ [ 1023, 1024 ], [ 1, 1024 ], [ 1023, 1024 ], [ 1024, 1 ] ] );
<multidigraph with 1024 vertices, 1026 edges>]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphRemoveEdges">
<ManSection>
  <Oper Name="DigraphRemoveEdges" Arg="digraph, edges"/>
  <Returns>A digraph.</Returns>
  <Description>
    If:
    <List>
      <Item>
        <A>digraph</A> is a digraph with no multiple edges, and <A>edges</A> is 
        a list of pairs of vertices of <A>digraph</A>, or
      </Item>
      <Item>
        <A>digraph</A> is any digraph and <A>edges</A> is a list of indices of 
        edges of <A>digraph</A>,
      </Item>
    </List>
    
    then this operation returns a digraph constructed from <A>digraph</A> by 
    removing all of the edges specified by <A>edges</A>. <P/>

    <Example><![CDATA[
gap> cycle := function(n)
>  local record, i;
>  record := rec( nrvertices := n, source := [  ], range := [  ] );
>  for i in [ 0 .. n - 1 ] do 
>    Add(record.source, i mod n + 1);
>    Add(record.range, (i + 1) mod n + 1);
>  od;
>  return Digraph(record);
> end;;
gap> gr := cycle(250000);
<digraph with 250000 vertices, 250000 edges>
gap> gr := DigraphRemoveEdges(gr, [ [ 250000, 1 ] ]);
<digraph with 250000 vertices, 249999 edges>
gap> gr := DigraphRemoveEdges(gr, [ 10 ]);
<digraph with 250000 vertices, 249998 edges>]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphReflexiveTransitiveClosure">
<ManSection>
  <Oper Name="DigraphReflexiveTransitiveClosure" Arg="digraph"/>
  <Oper Name="DigraphTransitiveClosure" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph with no multiple edges, these functions 
    return the (reflexive) transitive closure of the <A>digraph</A>. <P/>

    A digraph is <E>reflexive</E> if it has a loop at every vertex, and it is 
    <E>transitive</E> if whenever <C>[ i, j ]</C> and <C>[ j, k ]</C> are edges,
    <C>[ i, k ]</C> is also an edge. The <E>(reflexive) transitive closure</E> 
    of a digraph <A>digraph</A> is the least (reflexive and) transitive digraph 
    containing <A>digraph</A>. <P/>

    The methods used in this operation have complexity <M>O(n^3)</M>, where 
    <M>n</M> is the number of vertices of the digraph. <P/>

    <Example><![CDATA[
gap> gr:=Digraph( [ [ 4, 6 ], [ 1, 3 ], [ ], [ 5 ], [ ], [ 7, 8, 9 ], 
> [ ], [ ], [ ] ] );;
gap> DigraphTransitiveClosure(gr);
<digraph with 9 vertices, 18 edges>
gap> OutNeighbours(last);
[ [ 4, 5, 6, 7, 8, 9 ], [ 1, 3, 4, 5, 6, 7, 8, 9 ], [  ], [ 5 ], 
  [  ], [ 7, 8, 9 ], [  ], [  ], [  ] ]
gap> DigraphReflexiveTransitiveClosure(gr);  
<digraph with 9 vertices, 27 edges>
gap> OutNeighbours(last);
[ [ 1, 4, 5, 6, 7, 8, 9 ], [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 3 ], 
  [ 4, 5 ], [ 5 ], [ 6, 7, 8, 9 ], [ 7 ], [ 8 ], [ 9 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="InducedSubdigraph">
<ManSection>
  <Oper Name="InducedSubdigraph" Arg="digraph, verts"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, and <A>verts</A> is a subset of the 
    vertices of <A>digraph</A>, then this operation returns a digraph 
    constructed from <A>digraph</A> by retaining precisely those vertices in 
    <A>verts</A>, and those edges whose source and range are both contained in
    <A>verts</A>. <P/>
    The vertices of the induced subdigraph are 
    <C>[ 1 .. Length(verts) ]</C> but the original names can be accessed via 
    <Ref Oper="DigraphVertexNames"/>.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 1, 1, 2, 3, 4, 4 ], [ 1, 3, 4 ], [ 3, 1 ], 
> [ 1, 1 ] ] ); 
<multidigraph with 4 vertices, 13 edges>
gap> InducedSubdigraph( gr, [ 1, 3, 4 ] );                 
<multidigraph with 3 vertices, 9 edges>
gap> DigraphVertices(last);
[ 1 .. 3 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="OutDegreeOfVertex">
<ManSection>
  <Oper Name="OutDegreeOfVertex" Arg="digraph, vertex"/>
  <Returns>The non-negative integer.</Returns>
  <Description>
    Returns the out-degree of <A>vertex</A> in <A>digraph</A>; specifically,
    the number of edges in <A>digraph</A> whose source is <A>vertex</A>.
    <P/>
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 2, 1 ], [ 1, 4 ], [ 2, 2, 4, 2 ], 
> [ 1, 1, 2, 2, 1, 2, 2 ] ] );
<multidigraph with 4 vertices, 16 edges>
gap> OutDegreeOfVertex(gr, 1);
3
gap> OutDegreeOfVertex(gr, 2);
2
gap> OutDegreeOfVertex(gr, 3);
4
gap> OutDegreeOfVertex(gr, 4);
7
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="OutNeighboursOfVertex">
<ManSection>
  <Oper Name="OutNeighboursOfVertex" Arg="digraph, vertex"/>
  <Oper Name="OutNeighborsOfVertex" Arg="digraph, vertex"/>
  <Returns>A list of positive integers.</Returns>
  <Description>
    Returns the list <C>out</C> such that a vertex <C>i</C> is in <C>out</C>
    whenever there is an edge from <A>vertex</A> to <C>i</C> in <A>digraph</A>.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 2, 3 ], [ 1, 3, 4 ], [ 2, 2, 3 ], 
> [ 1, 1, 2, 2, 1, 2, 2 ] ] );
<multidigraph with 4 vertices, 16 edges>
gap> OutNeighboursOfVertex(gr, 1);
[ 2, 2, 3 ]
gap> OutNeighboursOfVertex(gr, 3);
[ 2, 2, 3 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="InDegreeOfVertex">
<ManSection>
  <Oper Name="InDegreeOfVertex" Arg="digraph, vertex"/>
  <Returns>A non-negative integer.</Returns>
  <Description>
    Returns the in-degree of <A>vertex</A> in <A>digraph</A>; specifically,
    the number of edges in <A>digraph</A> whose range is <A>vertex</A>.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 2, 1 ], [ 1, 4 ], [ 2, 2, 4, 2 ], 
> [ 1, 1, 2, 2, 1, 2, 2 ] ] );
<multidigraph with 4 vertices, 16 edges>
gap> InDegreeOfVertex(gr, 1);
5
gap> InDegreeOfVertex(gr, 2);
9
gap> InDegreeOfVertex(gr, 3);
0
gap> InDegreeOfVertex(gr, 4);
2
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="InNeighboursOfVertex">
<ManSection>
  <Oper Name="InNeighboursOfVertex" Arg="digraph, vertex"/>
  <Oper Name="InNeighborsOfVertex" Arg="digraph, vertex"/>
  <Returns>A list of postitive integers.</Returns>
  <Description>
    Returns the list <C>inn</C> such that a vertex <C>i</C> is in <C>inn</C>
    whenever there is an edge from <C>i</C> to <A>vertex</A> in <A>digraph</A>.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 2, 3 ], [ 1, 3, 4 ], [ 2, 2, 3 ], 
> [ 1, 1, 2, 2, 1, 2, 2 ] ] );
<multidigraph with 4 vertices, 16 edges>
gap> InNeighboursOfVertex(gr, 1);
[ 2, 4, 4, 4 ]
gap> InNeighboursOfVertex(gr, 2);
[ 1, 1, 3, 3, 4, 4, 4, 4 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphInEdges">
<ManSection>
  <Oper Name="DigraphInEdges" Arg="digraph, vertex"/>
  <Returns>A list of edges.</Returns>
  <Description>
    <C>DigraphInEdges</C> returns the list of all edges of <A>digraph</A>
    which have <A>vertex</A> as their range. 
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 2 ], [ 3, 3 ], [ 4, 4 ], [ 1, 1 ] ] );
<multidigraph with 4 vertices, 8 edges>
gap> DigraphInEdges(gr, 2);
[ [ 1, 2 ], [ 1, 2 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphOutEdges">
<ManSection>
  <Oper Name="DigraphOutEdges" Arg="digraph, vertex"/>
  <Returns>A list of edges.</Returns>
  <Description>
    <C>DigraphOutEdges</C> returns the list of all edges of <A>digraph</A>
    which have <A>vertex</A> as their source.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 2 ], [ 3, 3 ], [ 4, 4 ], [ 1, 1 ] ] );
<multidigraph with 4 vertices, 8 edges>
gap> DigraphOutEdges(gr, 2);
[ [ 2, 3 ], [ 2, 3 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphStronglyConnectedComponent">
<ManSection>
  <Oper Name="DigraphStronglyConnectedComponent" Arg="digraph, vertex"/>
  <Returns>A list of vertices.</Returns>
  <Description>
    <C>DigraphStronglyConnectedComponent</C> returns the strongly connected
    component of <A>vertex</A> in <A>digraph</A>.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 2 ], [ 1, 2 ], [ 3 ] ] );
<digraph with 4 vertices, 5 edges>
gap> DigraphStronglyConnectedComponent(gr, 3);
[ 1, 3 ]
gap> DigraphStronglyConnectedComponent(gr, 2);
[ 2 ]
gap> DigraphStronglyConnectedComponent(gr, 4);
[ 4 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="QuotientDigraph">
<ManSection>
  <Oper Name="QuotientDigraph" Arg="digraph, p"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, and <A>p</A> is a 
    partition of the vertices of <A>digraph</A>, then this operation returns a
    new digraph constructed by amalgamating all vertices of <A>digraph</A> 
    which lie in the same part of <A>p</A>. <P/>

    A partition of the vertices of <A>digraph</A> is a list of non-empty 
    disjoint lists, such that the concatenation of all the sub-lists is
    equal to the vertex set of <A>digraph</A>. In particular, each vertex
    must appear in precisely one sub-list. <P/>

    The vertices of <A>digraph</A> in part <C>i</C> of <A>p</A> will become 
    vertex <C>i</C> in the quotient, and an edge of <A>digraph</A> with 
    source (range) vertex in part <C>i</C> will have source (range) <C>i</C> in 
    the quotient. <P/>
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 1 ], [ 4 ], [ 1 ], [ 1, 3, 4 ] ] );
<digraph with 4 vertices, 7 edges>
gap> DigraphVertices(gr);
[ 1 .. 4 ]
gap> DigraphEdges(gr);
[ [ 1, 2 ], [ 1, 1 ], [ 2, 4 ], [ 3, 1 ], [ 4, 1 ], [ 4, 3 ], 
  [ 4, 4 ] ]
gap> p := [ [ 1 ], [ 2, 4 ], [ 3 ] ];
[ [ 1 ], [ 2, 4 ], [ 3 ] ]
gap> qr := QuotientDigraph( gr, p );
<multidigraph with 3 vertices, 7 edges>
gap> DigraphVertices(qr);
[ 1 .. 3 ]
gap> DigraphEdges(qr);
[ [ 1, 2 ], [ 1, 1 ], [ 2, 2 ], [ 2, 1 ], [ 2, 3 ], [ 2, 2 ], 
  [ 3, 1 ] ]
gap> QuotientDigraph( EmptyDigraph(0), [ ] );
<digraph with 0 vertices, 0 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsDigraphEdge">
<ManSection>
  <Oper Name="IsDigraphEdge" Arg="digraph, list"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    Returns true if and only if the list <A>list</A> specifies an edge in
    the digraph <A>digraph</A>.
    Specifically, this operation returns true if <A>list</A> is a pair of 
    positive integers where <A>list</A><C>[1]</C> is the source and 
    <A>list</A><C>[2]</C> is the range of an edge in <A>digraph</A>, and false 
    otherwise. <P/>
<Example><![CDATA[
gap> gr := Digraph( rec( nrvertices := 6,
> source := [ 1, 1, 2, 4, 6 ],
> range  := [ 2, 2, 6, 3, 1 ] ) );
<multidigraph with 6 vertices, 5 edges>
gap> IsDigraphEdge( gr, [ 1, 1 ] );
false
gap> IsDigraphEdge( gr, [ 1, 2 ] );
true
gap> IsDigraphEdge( gr, [ 1, 8 ] );
false
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphFloydWarshall">
<ManSection>
  <Oper Name="DigraphFloydWarshall" Arg="digraph, func, nopath, edge"/>
  <Returns>A matrix.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph with <M>n</M> vertices, then
    this function returns an <M>n \times n</M> matrix <C>mat</C> containing 
    the output of a generalised version of the Floyd-Warshall algorithm,
    applied to <A>digraph</A>. <P/>
    
    The function <C>DigraphFloydWarshall</C> is customised by the arguments 
    <A>func</A>, <A>nopath</A>, and <A>edge</A>.
    The arguments <A>nopath</A> and <A>edge</A> can be arbitrary &GAP; objects. 
    The argument <A>func</A> must be a function which accepts 4 arguments:
    the matrix <C>mat</C>, followed by 3 postive integers. The function
    <A>func</A> is where the work to calculate the desired outcome must be
    performed. <P/>
    
    This method initialises the matrix <C>mat</C> by setting entry 
    <C>mat[i][j]</C> to equal <A>edge</A> if there is an edge with source 
    <C>i</C> and range <C>j</C>, and by setting entry <C>mat[i][j]</C> to equal
    <A>nopath</A> otherwise.
    The final part of <C>DigraphFloydWarshall</C> then calls the function
    <A>func</A> inside three nested for loops, over the vertices of
    <A>digraph</A>: <P/>

<Listing><![CDATA[
for i in DigraphsVertices(digraph) do
  for j in DigraphsVertices(digraph) do
    for k in DigraphsVertices(digraph) do
      func(mat, i, j, k);
    od;
  od;
od;
]]></Listing>

    The matrix <C>mat</C> is then returned as the result. An example of using
    <C>DigraphFloydWarshall</C> to calculate the shortest distances between the
    vertices of a digraph is shown below: <P/>

    <Example><![CDATA[
gap> gr := Digraph( [ [ 5 ], [ 3, 6 ], [ 2, 5 ], [ 1, 4, 5 ],
> [ 4, 6 ], [ 5, 6 ] ] );
<digraph with 6 vertices, 12 edges>
gap> func := function(mat, i, j, k)
>   if mat[i][k] <> -1 and mat[k][j] <> -1 then
>     if (mat[i][j] = -1) or (mat[i][j] > mat[i][k] + mat[k][j]) then
>       mat[i][j] := mat[i][k] + mat[k][j];
>     fi;
>   fi;
> end;
function( mat, i, j, k ) ... end
gap> shortest_distances := DigraphFloydWarshall( gr, func, -1, 1 );;
gap> shortest_distances = DigraphShortestDistances(gr);
true
gap> Display(shortest_distances);
[ [   3,  -1,  -1,   2,   1,   2 ],
  [   4,   2,   1,   3,   2,   1 ],
  [   3,   1,   2,   2,   1,   2 ],
  [   1,  -1,  -1,   1,   1,   2 ],
  [   2,  -1,  -1,   1,   2,   1 ],
  [   3,  -1,  -1,   2,   1,   1 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="AsBinaryRelation">
<ManSection>
  <Oper Name="AsBinaryRelation" Arg="digraph"/>
  <Returns>A binary relation.</Returns>
  <Description>
    If <A>digraph</A> is a digraph with a positive number of vertices <M>n</M>,
    and no multiple edges, then this function returns a binary relation on
    the points <C>[ 1 .. n ]</C>. The pair <C>[ i, j ]</C> is in the binary
    relation if and only if <C>[ i, j ]</C> is an edge in <A>digraph</A>. 
    <P/>
<Example><![CDATA[
gap> gr := Digraph( [ [ 3, 2 ], [ 1, 2 ], [ 2 ], [ 3, 4 ] ] );
<digraph with 4 vertices, 7 edges>
gap> AsBinaryRelation(gr);
Binary Relation on 4 points
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphDisjointUnion">
<ManSection>
  <Oper Name="DigraphDisjointUnion" Arg="digraph1, digraph2"/>
  <Returns>A digraph.</Returns>
  <Description>
    Returns a digraph with the vertex and edge sets being the disjoint union of
    vertex and edge sets of <A>digraph1</A> and <A>digraph2</A> respectively. 
    <P/>
<Example><![CDATA[
gap> gr := CycleDigraph(10);
<digraph with 10 vertices, 10 edges>
gap> DigraphDisjointUnion(gr, gr);
<digraph with 20 vertices, 20 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphCopy">
<ManSection>
  <Oper Name="DigraphCopy" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    Returns a new copy of <A>digraph</A>.
<Example><![CDATA[
gap> gr := CycleDigraph(10);
<digraph with 10 vertices, 10 edges>
gap> DigraphCopy(gr) = gr;
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>
