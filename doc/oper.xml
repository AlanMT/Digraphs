#############################################################################
##
#W  oper.xml
#Y  Copyright (C) 2014                                  James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="DigraphVertexLabels">
<ManSection>
  <Oper Name="DigraphVertexLabels" Arg="digraph"/>
  <Oper Name="SetDigraphVertexLabels" Arg="digraph, list"/>
  <Oper Name="DigraphEdgeLabels" Arg="digraph"/>
  <Oper Name="SetDigraphEdgeLabels" Arg="digraph, list"/>
  <Description>
    If <A>digraph</A> is a digraph, then <C>DigraphVertexLabels</C> returns the labels 
    of the vertices in <A>digraph</A>. <C>SetDigraphVertexLabels</C> can be used to set 
    the labels of the vertices in <A>digraph</A> to the list of arbitrary 
    &GAP; objects <A>list</A>. 
    <C>DigraphEdgeLabels</C> and <C>SetDigraphEdgeLabels</C> are similar. <P/>

    The label of a vertex can be changed an arbitrary number of times. If no label
    has been set for the vertex <C>i</C>, then the default value is <C>i</C>.

    If <A>digraph</A> is a digraph created from a record with a component
    <C>vertices</C>, then the labels of the vertices are set to the value of this
    component.<P/>

    Induced subdigraphs, and other operations which create new digraphs from old
    ones, inherit their labels from their parents. 

    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ], 
> [ 2, 3, 5 ] ] );
<digraph with 5 vertices, 11 edges>
gap> DigraphVertexLabels(gr);
[ 1 .. 5 ]
gap> gr := Digraph( [ "a", "b", "c" ], [  ], [  ] );
<digraph with 3 vertices, 0 edges>
gap> DigraphVertexLabels(gr);
[ "a", "b", "c" ]
gap> SetDigraphVertexLabel(gr, 2, "d");
gap> DigraphVertexLabels(gr);
[ "a", "d", "c" ]
gap> gr := InducedSubdigraph(gr, [ 1, 3 ]);
<digraph with 2 vertices, 0 edges>
gap> DigraphVertexLabels(gr);
[ "a", "c" ]]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphVertexLabel">
<ManSection>
  <Oper Name="DigraphVertexLabel" Arg="digraph, i"/>
  <Oper Name="SetDigraphVertexLabel" Arg="digraph, i, obj"/>
  <Oper Name="DigraphEdgeLabel" Arg="digraph, i"/>
  <Oper Name="SetDigraphEdgeLabel" Arg="digraph, i, obj"/>
  <Description>
    If <A>digraph</A> is a digraph, then the first operation returns the label of
    the vertex <A>i</A>. The second operation can be used to set the label of the
    vertex <A>i</A> in <A>digraph</A> to the arbitrary &GAP; object <A>obj</A>. 
    <P/>

    The label of a vertex can be changed an arbitrary number of times. If no label
    has been set for the vertex <A>i</A>, then the default value is <C>i</C>. <P/>

    If <A>digraph</A> is a digraph created from a record with a component
    <C>vertices</C>, then the labels of the vertices are set to the value of this
    component.<P/>

    Induced subdigraphs, and other operations which create new digraphs from old
    ones, inherit their labels from their parents. 

    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ], 
> [ 2, 3, 5 ] ] );
<digraph with 5 vertices, 11 edges>
gap> DigraphVertexLabel(gr, 3);
3
gap> gr := Digraph( [ "a", "b", "c" ], [  ], [  ] );
<digraph with 3 vertices, 0 edges>
gap> DigraphVertexLabel(gr, 2);
"b"
gap> SetDigraphVertexLabel(gr, 2, "d");
gap> DigraphVertexLabel(gr, 2);
"d"
gap> gr := InducedSubdigraph(gr, [ 1, 2 ]);
<digraph with 2 vertices, 0 edges>
gap> DigraphVertexLabel(gr, 2);
"d"]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphReverse">
<ManSection>
  <Oper Name="DigraphReverse" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph, then this operation returns a digraph
    constructed from <A>digraph</A> by reversing the orientation of every edge.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ], 
> [ 2, 3, 5 ] ] );
<digraph with 5 vertices, 11 edges>
gap> DigraphReverse(gr);
<digraph with 5 vertices, 11 edges>
gap> OutNeighbours(last);
[ [ 2, 3, 4 ], [ 4, 5 ], [ 1, 2, 5 ], [ 4 ], [ 2, 5 ] ]
gap> gr := Digraph( 4,
> [ 1, 1, 1, 2, 3, 3, 4, 4 ], 
> [ 1, 2, 4, 1, 2, 4, 3, 4 ] );
<digraph with 4 vertices, 8 edges>
gap> gr := DigraphReverse(gr);
<digraph with 4 vertices, 8 edges>
gap> DigraphRange(gr);
[ 1, 2, 1, 3, 4, 1, 3, 4 ]
gap> DigraphSource(gr);
[ 1, 1, 2, 2, 3, 4, 4, 4 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphReverseEdges">
<ManSection>
  <Oper Name="DigraphReverseEdges" Arg="digraph, edges"/>
  <Oper Name="DigraphReverseEdge" Arg="digraph, edge"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph without multiple edges,
    and <A>edges</A> is either:

    <List>
      <Item>
        a list of pairs of vertices of <A>digraph</A>
        (the entries of each pair corresponding to
        the source and the range of an edge, respectively),
      </Item>
      <Item>
        a list of positions of elements in the list <Ref Oper="DigraphEdges"/>,
      </Item>
    </List>
    
    then <C>DigraphReverseEdges</C> returns a new digraph constructed from 
    <A>digraph</A> by reversing the orientation of every edge specified by
    <A>edges</A>. <P/>

    Note that even though <A>digraph</A> can not have multiple edges, the
    output may have multiple edges. <P/>
    <Example><![CDATA[
gap> gr := Digraph( 21,
> [ 1, 1, 1, 5, 7, 9, 11, 21 ],
> [ 7, 2, 8, 21, 19, 1, 2, 1 ]);
<digraph with 21 vertices, 8 edges>
gap> DigraphEdges(gr);
[ [ 1, 7 ], [ 1, 2 ], [ 1, 8 ], [ 5, 21 ], [ 7, 19 ], [ 9, 1 ], 
  [ 11, 2 ], [ 21, 1 ] ]
gap> gr2 := DigraphReverseEdges(gr, [ 1, 2, 4 ] );
<digraph with 21 vertices, 8 edges>
gap> gr = DigraphReverseEdges( gr2,
> [ [ 7, 1 ], [ 2, 1 ], [ 21, 5 ] ] );
true
gap> gr2 := DigraphReverseEdge(gr, 5);
<digraph with 21 vertices, 8 edges>
gap> gr2 = DigraphReverseEdge(gr, [ 7, 19 ]);
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="OnDigraphs">
<ManSection>
  <Oper Name="OnDigraphs" Arg="digraph, perm" Label="for a digraph and a perm"/>
  <Oper Name="OnDigraphs" Arg="digraph, trans" Label="for a digraph and a transformation"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, and the second argument is a permutation 
    <A>perm</A> of the vertices of <A>digraph</A>, then this operation returns
    a digraph constructed by relabelling the vertices of 
    <A>digraph</A> according to <A>perm</A>. <P/>

    If the second argument is a transformation <A>trans</A> of the vertices
    of <A>digraph</A>, then this operation returns the quotient of 
    <A>digraph</A> by the kernel of <A>trans</A>. <P/>
    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ], 
> [ 2, 3, 5 ] ] );
<digraph with 5 vertices, 11 edges>
gap> SetDigraphVertexLabels(gr, [ "a", "b", "c", "d", "e" ]);
gap> new := OnDigraphs(gr, (1,2));
<digraph with 5 vertices, 11 edges>
gap> OutNeighbours(new);
[ [ 2, 3, 5 ], [ 3 ], [ 2 ], [ 2, 1, 4 ], [ 1, 3, 5 ] ]
gap> DigraphVertexLabels(new);
[ "b", "a", "c", "d", "e" ]
gap> gr := Digraph( [ [ 2 ], [  ], [ 2 ] ] );
<digraph with 3 vertices, 2 edges>
gap> new := OnDigraphs(gr, Transformation( [ 1, 2, 1 ] ));
<multidigraph with 2 vertices, 2 edges>
gap> OutNeighbours(new);
[ [ 2, 2 ], [  ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="OnMultiDigraphs">
<ManSection>
  <Oper Name="OnMultiDigraphs" Arg="digraph, pair"/>
  <Oper Name="OnMultiDigraphs" Arg="digraph, perm1, perm2" Label="for a digraph, perm, and perm"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, and <A>pair</A> is a pair consisting of a
    permutation of the vertices and a permutation of the edges of
    <A>digraph</A>, then this operation returns a digraph
    constructed by relabelling the vertices and edges of <A>digraph</A> according to
    <A>perm[1]</A> and <A>perm[2]</A>, respectively. <P/>

    In its second form, <C>OnMultiDigraphs</C> returns a digraph with vertices
    and edges permuted by <A>perm1</A> and <A>perm2</A>, respectively. <P/>

    Note that <C>OnDigraphs(<A>digraph</A>,
      perm)=OnMultiDigraphs(<A>digraph</A>, [perm, ()])</C> where <C>perm</C> is
    a permutation of the vertices of <A>digraph</A>. If you are only interested
    in the action of a permutation on the vertices of a digraph, then you can
    use <C>OnDigraphs</C> instead of <C>OnMultiDigraphs</C>. 

    <Example><![CDATA[
gap> gr1 := Digraph( [ [ 3, 6, 3 ], [  ], [ 3 ], [ 9, 10 ], [ 9 ], 
> [  ],  [ ], [ 10, 4, 10 ], [  ], [  ] ] );
<multidigraph with 10 vertices, 10 edges>
gap> p := DigraphCanonicalLabelling(gr1);
[ (1,9,5,3,10,6,4,7), (1,7,9,5,2,8,4,10,3,6) ]
gap> gr2 := OnMultiDigraphs(gr1, p);
<multidigraph with 10 vertices, 10 edges>
gap> DigraphEdgeLabels(gr2);
[ 6, 5, 10, 8, 9, 3, 1, 2, 7, 4 ]
gap> DigraphVertexLabels(gr2);
[ 7, 2, 5, 6, 9, 10, 4, 8, 1, 3 ]]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphRemoveLoops">
<ManSection>
  <Oper Name="DigraphRemoveLoops" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph, then this operation returns a new
    digraph  constructed from <A>digraph</A> by removing every loop. A loop
    is an edge with equal source and range.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 1, 2, 4 ], [ 1, 4 ], [ 3, 4 ], [ 1, 4, 5 ], 
> [ 1, 5 ] ] );
<digraph with 5 vertices, 12 edges>
gap> DigraphRemoveLoops(gr);               
<digraph with 5 vertices, 8 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphRemoveAllMultipleEdges">
<ManSection>
  <Oper Name="DigraphRemoveAllMultipleEdges" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph, then this operation returns a new
    digraph  constructed from <A>digraph</A> by removing all multiple edges.
    The result is the largest subdigraph of <A>digraph</A> which does not 
    contain multiple edges. <P/>

    Note that previously set <Ref Attr="DigraphEdgeLabels"/> of <A>digraph</A>
    will be ignored by this operation. <P/>
    <Example><![CDATA[
gap> gr1 := Digraph( [ [ 1, 2, 3, 2 ], [ 1, 1, 3 ], [ 2, 2, 2 ] ] );
<multidigraph with 3 vertices, 10 edges>
gap> gr2 := DigraphRemoveAllMultipleEdges(gr1);
<digraph with 3 vertices, 6 edges>
gap> OutNeighbours(gr2);
[ [ 1, 2, 3 ], [ 1, 3 ], [ 2 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphAddVertex">
<ManSection>
  <Oper Name="DigraphAddVertex" Arg="digraph[, label ]"/>
  <Returns>A digraph.</Returns>
  <Description>
    The operation returns a new digraph constructed from <A>digraph</A> by
    adding a single new vertex. <P/>
    
    If the optional second argument <A>label</A> is an arbitrary &GAP; object,
    then the new vertex will be labelled <A>label</A>.
    <P/>
    <Example><![CDATA[
gap> gr := CompleteDigraph(3);
<digraph with 3 vertices, 6 edges>
gap> new := DigraphAddVertex(gr);
<digraph with 4 vertices, 6 edges>
gap> DigraphVertices(new);
[ 1 .. 4 ]
gap> new := DigraphAddVertex(gr, Group((1,2)));
<digraph with 4 vertices, 6 edges>
gap> DigraphVertexLabels(new);
[ 1, 2, 3, Group([ (1,2) ]) ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphAddVertices">
<ManSection>
  <Oper Name="DigraphAddVertices" Arg="digraph, m[, labels ]"/>
  <Returns>A digraph.</Returns>
  <Description>
    For a non-negative integer <A>m</A>, this operation returns a new digraph 
    constructed from <A>digraph</A> by adding <A>m</A> new vertices. <P/>
    
    If the optional third argument <A>labels</A> is a list of length <A>m</A> 
    consisting of arbitrary &GAP; objects, then the new vertices will be 
    labelled according to this list. <P/>
    <Example><![CDATA[
gap> gr := CompleteDigraph(3);
<digraph with 3 vertices, 6 edges>
gap> new := DigraphAddVertices(gr, 3);
<digraph with 6 vertices, 6 edges>
gap> DigraphVertices(new);
[ 1 .. 6 ]
gap> new := DigraphAddVertices(gr, 2, [ Group( [(1,2)] ), "d" ] );
<digraph with 5 vertices, 6 edges>
gap> DigraphVertexLabels(new);
[ 1, 2, 3, Group([ (1,2) ]), "d" ]
gap> DigraphAddVertices(gr, 0) = gr;
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphRemoveVertex">
<ManSection>
  <Oper Name="DigraphRemoveVertex" Arg="digraph, v"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>v</A> is a vertex of <A>digraph</A>, then this operation returns a 
    new digraph constructed from <A>digraph</A> by removing vertex <A>v</A>,
    along with any edge whose source or range vertex is <A>v</A>. <P/>

    If <A>digraph</A> has <C>n</C> vertices, then the vertices of the new
    digraph are <C>[1..n-1]</C>, but the original names can be 
    accessed via <Ref Oper="DigraphVertexLabels"/>. <P/>

    <Example><![CDATA[
gap> gr := Digraph( [ "a", "b", "c" ],
> [ "a", "a", "b", "c", "c" ],
> [ "b", "c", "a", "a", "c" ] );
<digraph with 3 vertices, 5 edges>
gap> DigraphVertexLabels(gr);
[ "a", "b", "c" ]
gap> DigraphEdges(gr);
[ [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 3, 1 ], [ 3, 3 ] ]
gap> new := DigraphRemoveVertex(gr, 2);
<digraph with 2 vertices, 3 edges>
gap> DigraphVertexLabels(new);
[ "a", "c" ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphRemoveVertices">
<ManSection>
  <Oper Name="DigraphRemoveVertices " Arg="digraph, verts"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>verts</A> is a (possibly empty) duplicate-free list of vertices of 
    <A>digraph</A>, then this operation returns a new digraph constructed from 
    <A>digraph</A> by removing every vertex in <A>verts</A>, along with any 
    edge whose source or range vertex is in <A>verts</A>. <P/>

    If <A>digraph</A> has <C>n</C> vertices, then the vertices of the new
    digraph are <C>[1..n-Length(<A>verts</A>)]</C>, but the 
    original names can be accessed via <Ref Oper="DigraphVertexLabels"/>. <P/>

    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ],
> [ 2, 3, 5 ] ] );
<digraph with 5 vertices, 11 edges>
gap> SetDigraphVertexLabels( gr, [ "a", "b", "c", "d", "e" ] );
gap> new := DigraphRemoveVertices(gr, [ 2, 4 ] );
<digraph with 3 vertices, 4 edges>
gap> DigraphVertexLabels(new);
[ "a", "c", "e" ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>


<#GAPDoc Label="DigraphAddEdge">
<ManSection>
  <Oper Name="DigraphAddEdge" Arg="digraph, edge[, label]"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>edge</A> is a pairs of vertices of <A>digraph</A>,
    then this operation returns a new digraph constructed from <A>digraph</A> 
    by adding a new edge with source <A>edge</A><C>[1]</C> and range 
    <A>edge</A><C>[2]</C>. <P/>

    If the optional second argument <A>label</A> is
    an arbitrary &GAP; object, then the new edge will be labelled <A>label</A>.
    <P/>

    <Example><![CDATA[
gap> gr1 := Digraph( [ [ 2 ], [ 3 ], [  ] ] );
<digraph with 3 vertices, 2 edges>
gap> DigraphEdges(gr1);
[ [ 1, 2 ], [ 2, 3 ] ]
gap> gr2 := DigraphAddEdge(gr1, [ 3, 1 ]);
<digraph with 3 vertices, 3 edges>
gap> DigraphEdges(gr2);
[ [ 1, 2 ], [ 2, 3 ], [ 3, 1 ] ]
gap> gr3 := DigraphAddEdge(gr2, [ 2, 3 ] );
<multidigraph with 3 vertices, 4 edges>
gap> DigraphEdges(gr3);
[ [ 1, 2 ], [ 2, 3 ], [ 2, 3 ], [ 3, 1 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphAddEdges">
<ManSection>
  <Oper Name="DigraphAddEdges" Arg="digraph, edges[, labels]"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>edges</A> is a (possibly empty) list of pairs of vertices of 
    <A>digraph</A>, then this operation returns a new digraph constructed from 
    <A>digraph</A> by adding the edges specified by <A>edges</A>.
    More precisely, for each position <C>i</C> of the list <A>edges</A>,
    a new edge will be added with source 
    <A>edges</A><C>[i][1]</C> and range <A>edges</A><C>[i][2]</C>.
    <P/>
    
    If an edge is included in <A>edges</A> with multiplicity <C>k</C>,
    then it will be added <C>k</C> times. <P/>

    If the optional third argument <A>labels</A> is a list with length equal
    to <C>Length(<A>edges</A>)</C> consisting of arbitrary &GAP; objects, then
    the new edges will be labelled according to this list. <P/>

    <Example><![CDATA[
gap> func := function(n)
>  local source, range, i;
>  source := [  ];
>  range  := [  ];
>  for i in [ 1 .. n - 2 ] do 
>    Add(source, i);
>    Add(range, i + 1);
>  od;
>  return Digraph( n, source, range );
> end;;
gap> gr := func(1024);
<digraph with 1024 vertices, 1022 edges>
gap> gr := DigraphAddEdges(gr,
> [ [ 1023, 1024 ], [ 1, 1024 ], [ 1023, 1024 ], [ 1024, 1 ] ] );
<multidigraph with 1024 vertices, 1026 edges>]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphRemoveEdges">
<ManSection>
  <Oper Name="DigraphRemoveEdges" Arg="digraph, edges"/>
  <Returns>A digraph.</Returns>
  <Description>
    If one of the following holds: 
    <List>
      <Item>
        <A>digraph</A> is a directed graph with no multiple edges, and 
        <A>edges</A> is a list of pairs of vertices of <A>digraph</A>, or
      </Item>
      <Item>
        <A>digraph</A> is any directed graph and <A>edges</A> is a list of 
        indices of edges of <A>digraph</A>,
      </Item>
    </List>
    
    then this operation returns a new digraph constructed from <A>digraph</A> 
    by removing all of the edges specified by <A>edges</A>. <P/>

    <Example><![CDATA[
gap> gr := CycleDigraph(250000);
<digraph with 250000 vertices, 250000 edges>
gap> gr := DigraphRemoveEdges(gr, [ [ 250000, 1 ] ]);
<digraph with 250000 vertices, 249999 edges>
gap> gr := DigraphRemoveEdges(gr, [ 10 ]);
<digraph with 250000 vertices, 249998 edges>]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphRemoveEdge">
<ManSection>
  <Oper Name="DigraphRemoveEdge" Arg="digraph, edge"/>
  <Returns>A digraph.</Returns>
  <Description>
    If one of the following holds: 
    <List>
      <Item>
        <A>digraph</A> is a directed graph with no multiple edges, and
        <A>edge</A> is a pair of vertices of <A>digraph</A>, or
      </Item>
      <Item>
        <A>digraph</A> is any directed graph and <A>edge</A> is the index of 
        an edge of <A>digraph</A>,
      </Item>
    </List>
    
    then this operation returns a new digraph constructed from <A>digraph</A> 
    by removing the edges specified by <A>edges</A>. If, in the first case,
    the pair of vertices <A>edge</A> does not specify an edge of <A>digraph</A>,
    then a new copy of <A>digraph</A> will be returned.<P/>

    <Example><![CDATA[
gap> gr := CycleDigraph(250000);
<digraph with 250000 vertices, 250000 edges>
gap> gr := DigraphRemoveEdge(gr, [ 250000, 1 ]);
<digraph with 250000 vertices, 249999 edges>
gap> gr := DigraphRemoveEdge(gr, 10);
<digraph with 250000 vertices, 249998 edges>]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>


<#GAPDoc Label="DigraphReflexiveTransitiveClosure">
<ManSection>
  <Oper Name="DigraphReflexiveTransitiveClosure" Arg="digraph"/>
  <Oper Name="DigraphTransitiveClosure" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph with no multiple edges, then these 
    functions  return the (reflexive) transitive closure of <A>digraph</A>. <P/>

    A digraph is <E>reflexive</E> if it has a loop at every vertex, and it is 
    <E>transitive</E> if whenever <C>[i,j]</C> and <C>[j,k]</C> are edges of 
    <A>digraph</A>, <C>[i,k]</C> is also an edge.
    The <E>(reflexive) transitive closure</E> 
    of a digraph <A>digraph</A> is the least (reflexive and) transitive digraph 
    containing <A>digraph</A>. <P/>

    Let <M>n</M> be the number of vertices of an arbitrary digraph, and let
        <M>m</M> be the number of edges.
    For general digraphs, the methods used for these operations use a version
    of the Floyd-Warshall algorithm, and have complexity <M>O(n^3)</M>.

    However, for digraphs which are topologically sortable
    [<Ref Attr="DigraphTopologicalSort"/>], then these operations will 
    use methods with complexity <M>O(m + n + m \cdot n)</M> when appropriate.
    <P/>
    <Example><![CDATA[
gap> gr := Digraph( [ [ 4, 6 ], [ 1, 3 ], [  ], [ 5 ], [  ],
> [ 7, 8, 9 ], [  ], [  ], [  ] ] );;
gap> DigraphTransitiveClosure(gr);
<digraph with 9 vertices, 18 edges>
gap> OutNeighbours(last);
[ [ 4, 5, 6, 7, 8, 9 ], [ 1, 3, 4, 5, 6, 7, 8, 9 ], [  ], [ 5 ], 
  [  ], [ 7, 8, 9 ], [  ], [  ], [  ] ]
gap> DigraphReflexiveTransitiveClosure(gr);  
<digraph with 9 vertices, 27 edges>
gap> OutNeighbours(last);
[ [ 1, 4, 5, 6, 7, 8, 9 ], [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 3 ], 
  [ 4, 5 ], [ 5 ], [ 6, 7, 8, 9 ], [ 7 ], [ 8 ], [ 9 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="InducedSubdigraph">
<ManSection>
  <Oper Name="InducedSubdigraph" Arg="digraph, verts"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph, and <A>verts</A> is a subset of the 
    vertices of <A>digraph</A>, then this operation returns a digraph 
    constructed from <A>digraph</A> by retaining precisely those vertices in 
    <A>verts</A>, and those edges whose source and range vertices are both
    contained in <A>verts</A>. <P/>

    The vertices of the induced subdigraph are 
    <C>[1..Length(verts)]</C> but the original vertex labels can be 
    accessed via <Ref Oper="DigraphVertexLabels"/>. <P/>

    <Example><![CDATA[
gap> gr := Digraph( [ [ 1, 1, 2, 3, 4, 4 ], [ 1, 3, 4 ], [ 3, 1 ], 
> [ 1, 1 ] ] ); 
<multidigraph with 4 vertices, 13 edges>
gap> InducedSubdigraph( gr, [ 1, 3, 4 ] );                 
<multidigraph with 3 vertices, 9 edges>
gap> DigraphVertices(last);
[ 1 .. 3 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="OutDegreeOfVertex">
<ManSection>
  <Oper Name="OutDegreeOfVertex" Arg="digraph, vertex"/>
  <Returns>The non-negative integer.</Returns>
  <Description>
    This function returns the out-degree of the vertex <A>vertex</A> in the 
    directed graph <A>digraph</A>.
    The out-degree of <A>vertex</A> is the number of edges in <A>digraph</A>
    whose source is <A>vertex</A>.
    <P/>
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 2, 1 ], [ 1, 4 ], [ 2, 2, 4, 2 ], 
> [ 1, 1, 2, 2, 1, 2, 2 ] ] );
<multidigraph with 4 vertices, 16 edges>
gap> OutDegreeOfVertex(gr, 1);
3
gap> OutDegreeOfVertex(gr, 2);
2
gap> OutDegreeOfVertex(gr, 3);
4
gap> OutDegreeOfVertex(gr, 4);
7
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="OutNeighboursOfVertex">
<ManSection>
  <Oper Name="OutNeighboursOfVertex" Arg="digraph, vertex"/>
  <Oper Name="OutNeighborsOfVertex" Arg="digraph, vertex"/>
  <Returns>A list of vertices.</Returns>
  <Description>

    This function returns the list <C>out</C> of vertices of the directed graph
    <A>digraph</A>.
    A vertex <C>i</C> appears in the list <C>out</C> each time there exists an
    edge  with source <A>vertex</A> and range <C>i</C> in <A>digraph</A>; in
    particular, this means that <C>out</C> may contain duplicates.<P/>
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 2, 3 ], [ 1, 3, 4 ], [ 2, 2, 3 ], 
> [ 1, 1, 2, 2, 1, 2, 2 ] ] );
<multidigraph with 4 vertices, 16 edges>
gap> OutNeighboursOfVertex(gr, 1);
[ 2, 2, 3 ]
gap> OutNeighboursOfVertex(gr, 3);
[ 2, 2, 3 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="InDegreeOfVertex">
<ManSection>
  <Oper Name="InDegreeOfVertex" Arg="digraph, vertex"/>
  <Returns>A non-negative integer.</Returns>
  <Description>
    This function returns the in-degree of the vertex <A>vertex</A> in the 
    directed graph <A>digraph</A>.
    The in-degree of <A>vertex</A> is the number of edges in <A>digraph</A>
    whose range is <A>vertex</A>.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 2, 1 ], [ 1, 4 ], [ 2, 2, 4, 2 ], 
> [ 1, 1, 2, 2, 1, 2, 2 ] ] );
<multidigraph with 4 vertices, 16 edges>
gap> InDegreeOfVertex(gr, 1);
5
gap> InDegreeOfVertex(gr, 2);
9
gap> InDegreeOfVertex(gr, 3);
0
gap> InDegreeOfVertex(gr, 4);
2
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="InNeighboursOfVertex">
<ManSection>
  <Oper Name="InNeighboursOfVertex" Arg="digraph, vertex"/>
  <Oper Name="InNeighborsOfVertex" Arg="digraph, vertex"/>
  <Returns>A list of postitive vertices.</Returns>
  <Description>

    This function returns the list <C>inn</C> of vertices of the directed graph
    <A>digraph</A>.
    A vertex <C>i</C> appears in the list <C>inn</C> each time there exists an 
    edge  with source <C>i</C> and range <A>vertex</A> in <A>digraph</A>; in
    particular, this means that <C>inn</C> may contain duplicates. <P/>

    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 2, 3 ], [ 1, 3, 4 ], [ 2, 2, 3 ], 
> [ 1, 1, 2, 2, 1, 2, 2 ] ] );
<multidigraph with 4 vertices, 16 edges>
gap> InNeighboursOfVertex(gr, 1);
[ 2, 4, 4, 4 ]
gap> InNeighboursOfVertex(gr, 2);
[ 1, 1, 3, 3, 4, 4, 4, 4 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphInEdges">
<ManSection>
  <Oper Name="DigraphInEdges" Arg="digraph, vertex"/>
  <Returns>A list of edges.</Returns>
  <Description>
    <C>DigraphInEdges</C> returns the list of all edges of <A>digraph</A>
    which have <A>vertex</A> as their range. 
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 2 ], [ 3, 3 ], [ 4, 4 ], [ 1, 1 ] ] );
<multidigraph with 4 vertices, 8 edges>
gap> DigraphInEdges(gr, 2);
[ [ 1, 2 ], [ 1, 2 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphOutEdges">
<ManSection>
  <Oper Name="DigraphOutEdges" Arg="digraph, vertex"/>
  <Returns>A list of edges.</Returns>
  <Description>
    <C>DigraphOutEdges</C> returns the list of all edges of <A>digraph</A>
    which have <A>vertex</A> as their source.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 2 ], [ 3, 3 ], [ 4, 4 ], [ 1, 1 ] ] );
<multidigraph with 4 vertices, 8 edges>
gap> DigraphOutEdges(gr, 2);
[ [ 2, 3 ], [ 2, 3 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphStronglyConnectedComponent">
<ManSection>
  <Oper Name="DigraphStronglyConnectedComponent" Arg="digraph, vertex"/>
  <Returns>A list of vertices.</Returns>
  <Description>
    If <A>vertex</A> is a vertex in the directed graph <A>digraph</A>, then
    this function returns the strongly connected component of <A>vertex</A> 
    in <A>digraph</A>.
    See <Ref Attr="DigraphStronglyConnectedComponents"/> for more information.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 2 ], [ 1, 2 ], [ 3 ] ] );
<digraph with 4 vertices, 5 edges>
gap> DigraphStronglyConnectedComponent(gr, 3);
[ 1, 3 ]
gap> DigraphStronglyConnectedComponent(gr, 2);
[ 2 ]
gap> DigraphStronglyConnectedComponent(gr, 4);
[ 4 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphConnectedComponent">
<ManSection>
  <Oper Name="DigraphConnectedComponent" Arg="digraph, vertex"/>
  <Returns>A list of vertices.</Returns>
  <Description>
    If <A>vertex</A> is a vertex in the directed graph <A>digraph</A>, then
    this function returns the connected component of <A>vertex</A> 
    in <A>digraph</A>.
    See <Ref Attr="DigraphConnectedComponents"/> for more information.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 3 ], [ 2 ], [ 1, 2 ], [ 4 ] ] );
<digraph with 4 vertices, 5 edges>
gap> DigraphConnectedComponent(gr, 3);
[ 1, 2, 3 ]
gap> DigraphConnectedComponent(gr, 2);
[ 1, 2, 3 ]
gap> DigraphConnectedComponent(gr, 4);
[ 4 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="QuotientDigraph">
<ManSection>
  <Oper Name="QuotientDigraph" Arg="digraph, p"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, and <A>p</A> is a 
    partition of the vertices of <A>digraph</A>, then this operation returns a
    new digraph constructed by amalgamating all vertices of <A>digraph</A> 
    which lie in the same part of <A>p</A>. <P/>

    A partition of the vertices of <A>digraph</A> is a list of non-empty 
    disjoint lists, such that the concatenation of all the sub-lists is
    equal to the vertex set of <A>digraph</A>. In particular, each vertex
    must appear in precisely one sub-list. <P/>

    The vertices of <A>digraph</A> in part <C>i</C> of <A>p</A> will become 
    vertex <C>i</C> in the quotient, and an edge of <A>digraph</A> with 
    source (range) vertex in part <C>i</C> will have source (range) <C>i</C> in 
    the quotient. <P/>
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 1 ], [ 4 ], [ 1 ], [ 1, 3, 4 ] ] );
<digraph with 4 vertices, 7 edges>
gap> DigraphVertices(gr);
[ 1 .. 4 ]
gap> DigraphEdges(gr);
[ [ 1, 2 ], [ 1, 1 ], [ 2, 4 ], [ 3, 1 ], [ 4, 1 ], [ 4, 3 ], 
  [ 4, 4 ] ]
gap> p := [ [ 1 ], [ 2, 4 ], [ 3 ] ];
[ [ 1 ], [ 2, 4 ], [ 3 ] ]
gap> qr := QuotientDigraph( gr, p );
<multidigraph with 3 vertices, 7 edges>
gap> DigraphVertices(qr);
[ 1 .. 3 ]
gap> DigraphEdges(qr);
[ [ 1, 2 ], [ 1, 1 ], [ 2, 2 ], [ 2, 1 ], [ 2, 3 ], [ 2, 2 ], 
  [ 3, 1 ] ]
gap> QuotientDigraph( EmptyDigraph(0), [ ] );
<digraph with 0 vertices, 0 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsDigraphEdge">
<ManSection>
  <Oper Name="IsDigraphEdge" Arg="digraph, list"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    Returns true if and only if the list <A>list</A> specifies an edge in
    the digraph <A>digraph</A>.
    Specifically, this operation returns true if <A>list</A> is a pair of 
    positive integers where <A>list</A><C>[1]</C> is the source and 
    <A>list</A><C>[2]</C> is the range of an edge in <A>digraph</A>, and false 
    otherwise. <P/>
<Example><![CDATA[
gap> gr := Digraph( 6, [ 1, 1, 2, 4, 6 ], [ 2, 2, 6, 3, 1 ] );
<multidigraph with 6 vertices, 5 edges>
gap> IsDigraphEdge( gr, [ 1, 1 ] );
false
gap> IsDigraphEdge( gr, [ 1, 2 ] );
true
gap> IsDigraphEdge( gr, [ 1, 8 ] );
false
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphFloydWarshall">
<ManSection>
  <Oper Name="DigraphFloydWarshall" Arg="digraph, func, nopath, edge"/>
  <Returns>A matrix.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph with <M>n</M> vertices, then
    this function returns an <M>n \times n</M> matrix <C>mat</C> containing 
    the output of a generalised version of the Floyd-Warshall algorithm,
    applied to <A>digraph</A>. <P/>
    
    The function <C>DigraphFloydWarshall</C> is customised by the arguments 
    <A>func</A>, <A>nopath</A>, and <A>edge</A>.
    The arguments <A>nopath</A> and <A>edge</A> can be arbitrary &GAP; objects. 
    The argument <A>func</A> must be a function which accepts 4 arguments:
    the matrix <C>mat</C>, followed by 3 postive integers. The function
    <A>func</A> is where the work to calculate the desired outcome must be
    performed. <P/>
    
    This method initialises the matrix <C>mat</C> by setting entry 
    <C>mat[i][j]</C> to equal <A>edge</A> if there is an edge with source 
    <C>i</C> and range <C>j</C>, and by setting entry <C>mat[i][j]</C> to equal
    <A>nopath</A> otherwise.
    The final part of <C>DigraphFloydWarshall</C> then calls the function
    <A>func</A> inside three nested for loops, over the vertices of
    <A>digraph</A>: <P/>

<Listing><![CDATA[
for i in DigraphsVertices(digraph) do
  for j in DigraphsVertices(digraph) do
    for k in DigraphsVertices(digraph) do
      func(mat, i, j, k);
    od;
  od;
od;
]]></Listing>

    The matrix <C>mat</C> is then returned as the result. An example of using
    <C>DigraphFloydWarshall</C> to calculate the shortest (non-zero) distances
    between the vertices of a digraph is shown below: <P/>

    <Example><![CDATA[
gap> gr := Digraph( [ [ 5 ], [ 3, 6 ], [ 2, 5 ], [ 1, 4, 5 ],
> [ 4, 6 ], [ 5, 6 ] ] );
<digraph with 6 vertices, 12 edges>
gap> func := function(mat, i, j, k)
>   if mat[i][k] <> -1 and mat[k][j] <> -1 then
>     if (mat[i][j] = -1) or (mat[i][j] > mat[i][k] + mat[k][j]) then
>       mat[i][j] := mat[i][k] + mat[k][j];
>     fi;
>   fi;
> end;
function( mat, i, j, k ) ... end
gap> shortest_distances := DigraphFloydWarshall( gr, func, -1, 1 );;
gap> Display(shortest_distances);
[ [   3,  -1,  -1,   2,   1,   2 ],
  [   4,   2,   1,   3,   2,   1 ],
  [   3,   1,   2,   2,   1,   2 ],
  [   1,  -1,  -1,   1,   1,   2 ],
  [   2,  -1,  -1,   1,   2,   1 ],
  [   3,  -1,  -1,   2,   1,   1 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="AsBinaryRelation">
<ManSection>
  <Oper Name="AsBinaryRelation" Arg="digraph"/>
  <Returns>A binary relation.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph with a positive number of vertices 
    <M>n</M>, and no multiple edges, then this function returns a binary 
    relation on the points <C>[1..n]</C>.
    The pair <C>[i,j]</C> is in the binary relation if and only if
    <C>[i,j]</C> is an edge in <A>digraph</A>. 
    <P/>
<Example><![CDATA[
gap> gr := Digraph( [ [ 3, 2 ], [ 1, 2 ], [ 2 ], [ 3, 4 ] ] );
<digraph with 4 vertices, 7 edges>
gap> AsBinaryRelation(gr);
Binary Relation on 4 points
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphEdgeUnion">
<ManSection>
  <Oper Name="DigraphEdgeUnion" Arg="digraph1, digraph2"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph1</A> and <A>digraph2</A> are directed graphs, then this 
    function returns the edge union of these digraphs. <P/>
   
    The vertex and edge sets of the edge union are the union of
    the vertex sets and the concatenation of the edge sets of <A>digraph1</A>
    and <A>digraph2</A> respectively.
    <P/>

    More specifically, if <A>digraph1</A> has <M>n_1</M> vertices and <M>m_1</M>
    edges, and if <A>digraph2</A> has <M>n_2</M> vertices and <M>m_2</M> edges,
    then <C>DigraphDisjointUnion(<A>digraph1</A>, <A>digraph2</A>)</C>
    will have <C>Maximum(</C><M>n_1, n_2</M><C>)</C> vertices and
    <M>m_1 + m_2</M> edges. 

    The vertices of <A>digraph1</A> will remain
    <C>[1..</C><M>n_1</M><C>]</C> in the edge union,
    and the vertices of <A>digraph2</A> will remain
    <C>[</C><M>1</M><C>..</C><M>n_2</M><C>]</C>. <P/>

    Note that previously set <Ref Attr="DigraphVertexLabels"/> and
    <Ref Attr="DigraphEdgeLabels"/> will be lost.
    
<Example><![CDATA[
gap> gr := CycleDigraph(10);
<digraph with 10 vertices, 10 edges>
gap> DigraphEdgeUnion(gr, gr);
<multidigraph with 10 vertices, 20 edges>
gap> gr1 := Digraph( [ [ 2 ], [ 1 ] ] );
<digraph with 2 vertices, 2 edges>
gap> gr2 := Digraph( [ [ 2, 3 ], [ 2 ], [ 1 ] ] );
<digraph with 3 vertices, 4 edges>
gap> union := DigraphEdgeUnion(gr1, gr2);
<multidigraph with 3 vertices, 6 edges>
gap> OutNeighbours(union);
[ [ 2, 2, 3 ], [ 1, 2 ], [ 1 ] ]
gap> unionofedges := Concatenation(
> DigraphEdges(gr1), DigraphEdges(gr2));;
gap> union = DigraphByEdges(unionofedges);
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphDisjointUnion">
<ManSection>
  <Oper Name="DigraphDisjointUnion" Arg="digraph1, digraph2"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph1</A> and <A>digraph2</A> are directed graphs, then this 
    function returns the disjoint union of these digraphs. <P/>
   
    The vertex and edge sets of the disjoint union are the disjoint union of
    the vertex and edge sets of <A>digraph1</A> and <A>digraph2</A> 
    respectively.
    <P/>

    More specifically, if <A>digraph1</A> has <M>n_1</M> vertices and <M>m_1</M>
    edges, and if <A>digraph2</A> has <M>n_2</M> vertices and <M>m_2</M> edges,
    then <C>DigraphDisjointUnion(<A>digraph1</A>, <A>digraph2</A>)</C>
    will have <M>n_1 + n_2</M> vertices and <M>m_1 + m_2</M> edges. 

    The vertices of <A>digraph1</A> will remain
    <C>[1..</C><M>n_1</M><C>]</C> in the disjoint union.
    The vertices of <A>digraph2</A> will become
    <C>[</C><M>n_1+1</M><C>..</C><M>n_1+n_2</M><C>]</C>,
    and an edge <C>[</C><M>i,j</M><C>]</C> in <A>digraph2</A> will become
    the edge <C>[</C><M>n_1+i,n_1+j</M><C>]</C>.<P/>

    Note that previously set <Ref Attr="DigraphVertexLabels"/> and
    <Ref Attr="DigraphEdgeLabels"/> will be lost.
    
<Example><![CDATA[
gap> gr1 := CycleDigraph(3);
<digraph with 3 vertices, 3 edges>
gap> OutNeighbours(gr1);
[ [ 2 ], [ 3 ], [ 1 ] ]
gap> gr2 := CompleteDigraph(3);
<digraph with 3 vertices, 6 edges>
gap> OutNeighbours(gr2);
[ [ 2, 3 ], [ 1, 3 ], [ 1, 2 ] ]
gap> union := DigraphDisjointUnion(gr1, gr2);
<digraph with 6 vertices, 9 edges>
gap> OutNeighbours(union);
[ [ 2 ], [ 3 ], [ 1 ], [ 5, 6 ], [ 4, 6 ], [ 4, 5 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphJoin">
<ManSection>
  <Oper Name="DigraphJoin" Arg="digraph1, digraph2"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph1</A> and <A>digraph2</A> are directed graphs, then this
    function returns the join of these digraphs. <P/>
    
    Let <M>V_1</M>, <M>E_1</M> and <M>V_2</M>, <M>E_2</M> be vertex and edge 
    sets of the digraphs <A>digraph1</A> and <A>digraph2</A>, respectively.
    Then the vertex set of the join is the disjoint union of 
    <M>V_1</M> and <M>V_2</M>,
    and the edge set of the join is the disjoint union of 
    <M>E_1</M> and <M>E_2</M>,
    together with all possible edges between <M>V_1</M> and <M>V_2</M>. <P/>

    In particular, if <A>digraph1</A> has <M>n_1</M> vertices and <M>m_1</M>
    edges, and if <A>digraph2</A> has <M>n_2</M> vertices and <M>m_2</M> edges,
    then <C>DigraphJoin(<A>digraph1</A>, <A>digraph2</A>)</C> will
    have <M>n_1+n_2</M> vertices and <M>m_1+m_2+2n_1n_2</M> edges. <P/>

    The vertices of <A>digraph1</A> will remain
    <C>[1..</C><M>n_1</M><C>]</C>, in the new digraph.
    The vertices of <A>digraph2</A> will become
    <C>[</C><M>n_1+1</M><C>..</C><M>n_1+n_2</M><C>]</C>,
    and an edge <C>[</C><M>i,j</M><C>]</C> in <A>digraph2</A> will become
    the edge <C>[</C><M>n_1+i,n_1+j</M><C>]</C>. <P/>

    Note that previously set <Ref Attr="DigraphVertexLabels"/> and
    <Ref Attr="DigraphEdgeLabels"/> will be lost.

<Example><![CDATA[
gap> gr := CompleteDigraph(3);
<digraph with 3 vertices, 6 edges>
gap> IsCompleteDigraph(DigraphJoin(gr, gr));
true
gap> gr2 := CycleDigraph(3);
<digraph with 3 vertices, 3 edges>
gap> DigraphJoin(gr, gr2);
<digraph with 6 vertices, 27 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsReachable">
<ManSection>
  <Oper Name="IsReachable" Arg="digraph, u, v"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    This function returns <K>true</K> is there exists a directed path (of 
    non-zero length) from vertex <A>u</A> to vertex <A>v</A> in the directed 
    graph <A>digraph</A>, and <K>false</K> if there does not exist such a path.
<Example><![CDATA[
gap> gr := Digraph( [ [ 2 ], [ 3 ], [ 2, 3 ] ] );
<digraph with 3 vertices, 4 edges>
gap> IsReachable(gr, 1, 3);
true
gap> IsReachable(gr, 2, 1);
false
gap> IsReachable(gr, 3, 3);
true
gap> IsReachable(gr, 1, 1);
false
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphLongestDistanceFromVertex">
<ManSection>
  <Oper Name="DigraphLongestDistanceFromVertex" Arg="digraph, v"/>
  <Returns>An integer.</Returns>
  <Description>
    If <A>digraph</A> is a digraph and <A>v</A> is a vertex in <A>digraph</A>,
    then this function returns the length of the longest directed path in
    <A>digraph</A> which begins at vertex <A>v</A>. <P/>

    <List>
      <Item>
        If there exists a directed path starting at vertex <A>v</A>
        which traverses a cycle or a loop,
        then we consider there to be a path of infinite length from <A>v</A>
        (realised by repeatedly traversing the loop/cycle),
        and so the result is <C>-2</C>.
        To disallow paths using loops, try using
        <Ref Oper="DigraphRemoveLoops"/>:<P/>

        <C>DigraphLongestDistanceFromVertex(DigraphRemoveLoops(<A>digraph</A>,<A>v</A>))</C>.
      </Item>

      <Item>
        If no path from vertex <A>v</A> exists,
        i.e. if <A>v</A> is a sink of the digraph
        (<Ref Attr="DigraphSinks"/>), then the result is <C>0</C>.
      </Item>

      <Item>
        Otherwise, if all directed paths
        starting at vertex <A>v</A> have finite length,
        then the length of the longest such path is returned.
      </Item>
    </List>

<Example><![CDATA[
gap> gr := Digraph( [ [ 2 ], [ 3, 4 ], [  ], [ 5 ], [  ], [ 6 ] ] );
<digraph with 6 vertices, 5 edges>
gap> DigraphLongestDistanceFromVertex(gr, 1);
3
gap> DigraphLongestDistanceFromVertex(gr, 3);
0
gap> 3 in DigraphSinks(gr);
true
gap> DigraphLongestDistanceFromVertex(gr, 6);
-2
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>
