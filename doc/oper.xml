#############################################################################
##
#W  oper.xml
#Y  Copyright (C) 2014                                  James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="DirectedGraphReverse">
<ManSection>
  <Oper Name="DirectedGraphReverse" Arg="digraph"/>
  <Returns>A directed graph.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph, then this operation returns a directed graph
    constructed from <A>digraph</A> by reversing the edges.
    <Example><![CDATA[
gap> gr := DirectedGraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ], 
> [ 2, 3, 5 ] ] );
<directed graph with 5 vertices, 11 edges>
gap> DirectedGraphReverse(gr);
<directed graph with 5 vertices, 11 edges>
gap> Adjacencies(last);
[ [ 2, 3, 5 ], [ 3 ], [ 2 ], [ 1, 2, 4 ], [ 1, 3, 5 ] ]
gap> gr:=DirectedGraph(rec(nrvertices:=4, source:=[ 1, 1, 1, 2, 3, 3, 4, 4 ], 
> range:=[ 1, 2, 4, 1, 2, 4, 3, 4 ]));
<directed graph with 4 vertices, 8 edges>
gap> gr:=DirectedGraphReverse(gr);
<directed graph with 4 vertices, 8 edges>
gap> Range(gr);
[ 1, 2, 1, 3, 4, 1, 3, 4 ]
gap> Source(gr);
[ 1, 1, 2, 2, 3, 4, 4, 4 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DirectedGraphRelabel">
<ManSection>
  <Oper Name="DirectedGraphRelabel" Arg="digraph, perm"/>
  <Returns>A directed graph.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph, and <A>perm</A> is a permutation of
    the vertices of <A>digraph</A>, then this operation returns a directed graph
    constructed from <A>digraph</A> by relabelling the vertices according to
    <A>perm</A>. 
    <Example><![CDATA[
gap> gr := DirectedGraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ], 
> [ 2, 3, 5 ] ] );
<directed graph with 5 vertices, 11 edges>
gap> DirectedGraphRelabel(gr, (1,2));
<directed graph with 5 vertices, 11 edges>
gap> Adjacencies(last);
[ [ 2, 3, 5 ], [ 3 ], [ 2 ], [ 1, 2, 4 ], [ 1, 3, 5 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DirectedGraphRemoveLoops">
<ManSection>
  <Oper Name="DirectedGraphRemoveLoops" Arg="digraph"/>
  <Returns>A directed graph.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph, then this operation returns a directed graph 
    constructed from <A>digraph</A> by removing all of the loops (edges with
    equal source and range).
    <Example><![CDATA[
gap> gr:=DirectedGraph( [ [ 1, 2, 4 ], [ 1, 4 ], [ 3, 4 ], [ 1, 4, 5 ], 
> [ 1, 5 ] ] );
<directed graph with 5 vertices, 12 edges>
gap> DirectedGraphRemoveLoops(gr);                 
<directed graph with 5 vertices, 8 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DirectedGraphRemoveEdges">
<ManSection>
  <Oper Name="DirectedGraphRemoveEdges" Arg="digraph, edges"/>
  <Returns>A directed graph.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph and <A>edges</A> is a list of either:
    pairs of vertices of the simple directed graph <A>digraph</A> or indices of
    edges of <A>digraph</A>, then this operation returns a directed graph
    constructed from <A>digraph</A> by removing all of the edges specified by
    <A>edges</A>.

    <Example><![CDATA[
gap> cycle:=function(n)
>  local record, i;
>  record:=rec(vertices:=[1..n], source:=[], range:=[]);
>  for i in [0..n-1] do 
>    Add(record.source, i mod Length(record.vertices) + 1);
>    Add(record.range, (i + 1) mod Length(record.vertices) +1);
>  od;
>  return DirectedGraph(record);
> end;;
gap> gr:=cycle(250000);
<directed graph with 250000 vertices, 250000 edges>
gap> gr:=DirectedGraphRemoveEdges(gr, [[250000, 1]]);
<directed graph with 250000 vertices, 249999 edges>
gap> gr:=DirectedGraphRemoveEdges(gr, [10]);
<directed graph with 250000 vertices, 249998 edges>]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DirectedGraphTopologicalSort">
<ManSection>
  <Oper Name="DirectedGraphTopologicalSort" Arg="digraph"/>
  <Returns>A list of positive integers, or <K>fail</K>.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph with no cycles of length greater than
    <M>1</M>, then this operation returns the vertices of <A>digraph</A> 
    ordered so  that every vertex adjacent to <C>i</C> occurs before <C>i</C>. 
    If the directed graph <A>digraph</A> contains cycles of length greater than 
    <M>1</M>, then this operation returns <K>fail</K>.
    <P/>

    The method used in this operation has complexity <M>O(m+n)</M> where
    <M>m</M> is the number of edges (counting multiple edges as one) and
    <M>n</M> is the number of vertices in the directed graph. 
    <Example><![CDATA[
gap> gr:=DirectedGraph([[2,3], [],[4,6], [5], [], [7,8,9], [],[],[]]);
<directed graph with 9 vertices, 8 edges>
gap> DirectedGraphTopologicalSort(gr);
[ 2, 5, 4, 7, 8, 9, 6, 3, 1 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DirectedGraphReflexiveTransitiveClosure">
<ManSection>
  <Oper Name="DirectedGraphReflexiveTransitiveClosure" Arg="digraph"/>
  <Oper Name="DirectedGraphTransitiveClosure" Arg="digraph"/>
  <Returns>A directed graph.</Returns>
  <Description>
    The first of these functions returns the (reflexive) transitive closure
    of the simple directed graph <A>digraph</A>. <P/>

    A directed graph is <E>reflexive</E> if there is a loop at every
    vertex, and it is <E>transitive</E> if whenever <C>[ i, j ]</C> and 
    <C>[ j, k ]</C> are edges, <C>[ i, k ]</C> is also an edge. The 
    <E>transitive closure</E> of a directed graph <A>digraph</A> is the 
    least transitive directed graph containing <A>digraph</A>. 

    <Example><![CDATA[
gap> gr:=DirectedGraph( [ [ 4, 6 ], [ 1, 3 ], [ ], [ 5 ], [ ], [ 7, 8, 9 ], 
> [ ], [ ], [ ] ] );;
gap> DirectedGraphTransitiveClosure(gr);
<directed graph with 9 vertices, 18 edges>
gap> Adjacencies(last);
[ [ 4, 5, 6, 7, 8, 9 ], [ 1, 3, 4, 5, 6, 7, 8, 9 ], [  ], [ 5 ], 
  [  ], [ 7, 8, 9 ], [  ], [  ], [  ] ]
gap> DirectedGraphReflexiveTransitiveClosure(gr);  
<directed graph with 9 vertices, 27 edges>
gap> Adjacencies(last);
[ [ 1, 4, 5, 6, 7, 8, 9 ], [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 3 ], 
  [ 4, 5 ], [ 5 ], [ 6, 7, 8, 9 ], [ 7 ], [ 8 ], [ 9 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>


