#############################################################################
##
#W  prop.xml
#Y  Copyright (C) 2014                                  James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="IsAcyclicDigraph">
<ManSection>
  <Prop Name="IsAcyclicDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    Returns <K>true</K> if the digraph <A>digraph</A> is acyclic and
    <K>false</K> if it is not. A digraph is <E>acyclic</E> if
    there are no cycles, i.e. paths starting and ending at the same vertex. <P/>

    The method used in this operation has complexity <M>O(m+n)</M> where
    <M>m</M> is the number of edges (counting multiple edges as one) and
    <M>n</M> is the number of vertices in the digraph. 

    <Example><![CDATA[
gap> Petersen := Graph( SymmetricGroup(5), [[1,2]], OnSets,           
> function(x,y) return Intersection(x,y)=[]; end );;
gap> gr:=Digraph(Petersen);                    
<digraph with 10 vertices, 30 edges>
gap> IsAcyclicDigraph(gr);
false
gap> gr:=Digraph( [ [ ], [ 1 ], [ 1 ], [ 1 ], [ 3 ], [ 3 ], 
> [ 4 ], [ 4 ], [ 5 ], [ 5 ], [ 5 ], [ 6 ], [ 6 ], [ 7 ], [ 7 ], 
> [ 7 ], [ 8 ], [ 9 ], [ 9 ], [ 11 ], [ 11 ], [ 12 ], [ 12 ], [ 13 ], 
> [ 14 ], [ 15 ], [ 15 ], [ 16 ], [ 16 ], [ 17 ], [ 17 ], [ 18 ], 
> [ 18 ], [ 19 ], [ 20 ], [ 20 ], [ 21 ], [ 22 ], [ 22 ], [ 23 ], 
> [ 23 ], [ 24 ], [ 28 ], [ 29 ], [ 30 ], [ 30 ], [ 31 ], [ 32 ], 
> [ 32 ], [ 33 ], [ 34 ], [ 41 ], [ 46 ], [ 47 ], [ 51 ] ] );;
gap> IsAcyclicDigraph(gr);
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCompleteDigraph">
<ManSection>
  <Prop Name="IsCompleteDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    Returns <K>true</K> if the digraph <A>digraph</A> is complete, and 
    <K>false</K> if it is not. <P/>
    
    A digraph is <E>complete</E> if, for all vertices <C>i</C> and <C>j</C> 
    (including <C>i = j</C>), there is exactly one directed edge with source
    <C>i</C> and range <C>j</C>. 
    Equivalently, a digraph with <M>n</M> vertices is complete precisely when it 
    has <M>n^2</M> edges and no multiple edges.

    <Example><![CDATA[
gap> gr := Digraph( [ [ 1 ] ] );
<digraph with 1 vertex, 1 edge>
gap> IsCompleteDigraph(gr);
true
gap> gr := Digraph( [ [ 1, 2, 2 ], [ 1, 2 ] ] );
<multidigraph with 2 vertices, 5 edges>
gap> IsCompleteDigraph(gr);
false
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsEmptyDigraph">
<ManSection>
  <Prop Name="IsEmptyDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    Returns <K>true</K> if the digraph <A>digraph</A> is empty, and
    <K>false</K> if it is not. A digraph is <E>empty</E> if it has no edges.

    <Example><![CDATA[
gap> gr := Digraph( [ [ ], [ ] ] );
<digraph with 2 vertices, 0 edges>
gap> IsEmptyDigraph(gr);
true
gap> gr := Digraph( [ [ ], [ 1 ] ] );
<digraph with 2 vertices, 1 edge>
gap> IsEmptyDigraph(gr);
false
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsFunctionalDigraph">
<ManSection>
  <Prop Name="IsFunctionalDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    This function returns <K>true</K> if the digraph <A>digraph</A> is
    functional. <P/>
    
    A digraph is <E>functional</E> if every vertex is the source of a
    unique edge. 
    <Example><![CDATA[
gap> gr1 := Digraph( [ [ 3 ], [ 2 ], [ 2 ], [ 1 ], [ 6 ], [ 5 ] ] );
<digraph with 6 vertices, 6 edges>
gap> IsFunctionalDigraph(gr1);
true
gap> gr2 := Digraph( [ [ 1, 2 ], [ 1 ] ] );
<digraph with 2 vertices, 3 edges>
gap> IsFunctionalDigraph(gr2);
false
gap> gr3 := Digraph(
> rec( vertices := [ 1 .. 3 ], source := [ 1, 2, 3 ], 
> range := [ 2, 3, 1 ] ) );
<digraph with 3 vertices, 3 edges>
gap> IsFunctionalDigraph(gr3);
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsMultiDigraph">
<ManSection>
  <Prop Name="IsMultiDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    A <E>multidigraph</E> is one that has at least two 
    edges with equal source and range. 
    
    <Example><![CDATA[
gap> gr:=Digraph(rec(vertices:=["a", "b", "c"],
> source:=["a", "b", "b"], range:=["b", "c", "a"]));
<digraph with 3 vertices, 3 edges>
gap> IsMultiDigraph(gr);
false
gap> gr:=Digraph(rec(nrvertices:=3, 
> source:=[1,2,3,1,1,2], range:=[1,2,3,2,3,1]));
<digraph with 3 vertices, 6 edges>
gap> IsMultiDigraph(gr);
false
gap> gr:=Digraph(rec(nrvertices:=3,
> source:=[1,2,3,1,1,2,1], range:=[1,2,3,2,3,1,2]));
<multidigraph with 3 vertices, 7 edges>
gap> IsMultiDigraph(gr);
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsReflexiveDigraph">
<ManSection>
  <Prop Name="IsReflexiveDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    Returns <K>true</K> if the digraph <A>digraph</A> is reflexive, and
    <K>false</K> if it is not. A digraph is <E>reflexive</E> if it has a loop
    at every vertex.

    <Example><![CDATA[
gap> gr := Digraph( [ [ 1, 2 ], [ 2 ] ] );
<digraph with 2 vertices, 3 edges>
gap> IsReflexiveDigraph(gr);
true
gap> gr := Digraph( rec ( nrvertices := 4,
> source := [ 1, 1, 2, 2, 3, 4, 4 ], range := [ 3, 1, 4, 2, 3, 2, 1 ] )  );
<digraph with 4 vertices, 7 edges>
gap> IsReflexiveDigraph(gr);
false
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsStronglyConnectedDigraph">
<ManSection>
  <Prop Name="IsStronglyConnectedDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    This function returns <K>true</K> if the digraph <A>digraph</A> is
    strongly connected and <K>false</K> if it is not.  A digraph <A>digraph</A>
    is <E>strongly connected</E> if there is a path from every vertex to every
    other vertex. <P/>

    The method used in this operation is based on Gabow's Algorithm <Cite
      Key="Gabow2000aa"/> and has complexity <M>O(m+n)</M> where <M>m</M> is the
    number of edges (counting multiple edges as one) and <M>n</M> is the number
    of vertices in the digraph. 
  
    <Example><![CDATA[
gap> cycle:=function(n)
>  local record, i;
>  record:=rec(vertices:=[1..n], source:=[], range:=[]);
>  for i in [0..n-1] do 
>    Add(record.source, i mod Length(record.vertices) + 1);
>    Add(record.range, (i + 1) mod Length(record.vertices) +1);
>  od;
>  return Digraph(record);
> end;;
gap> gr:=cycle(250000);
<digraph with 250000 vertices, 250000 edges>
gap> IsStronglyConnectedDigraph(gr);
true
gap> gr:=DigraphRemoveEdges(gr, [[250000, 1]]);
<digraph with 250000 vertices, 249999 edges>
gap> IsStronglyConnectedDigraph(gr);
false
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSymmetricDigraph">
<ManSection>
  <Prop Name="IsSymmetricDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    A <E>symmetric digraph</E> is one where for each non-loop edge,
    having source <M>u</M> and range <M>v</M>, there is a corresponding edge
    with source v and range u. If there are <M>n</M> edges with source <M>u</M>
    and range <M>v</M>, then there must be precisely <M>n</M> edges with source
    <M>v</M> and range <M>u</M>.
    In other words, an undirected digraph has a symmetric adjacency 
    matrix <Ref Attr="AdjacencyMatrix"/>.<P/>

    This function returns true if and only if the digraph <A>digraph</A> 
    is symmetric.
    <Example><![CDATA[
gap> gr1 := Digraph( [ [ 2 ], [ 1, 3 ], [ 2, 3 ] ] );
<digraph with 3 vertices, 5 edges>
gap> IsSymmetricDigraph(gr1);
true
gap> adj1 := AdjacencyMatrix(gr1);;
gap> Display(adj1);
[ [  0,  1,  0 ],
  [  1,  0,  1 ],
  [  0,  1,  1 ] ]
gap> adj1 = TransposedMat(adj1);
true
gap> gr2 := Digraph( [ [ 2, 3 ], [ 1, 3 ], [ 2, 3 ] ] );
<digraph with 3 vertices, 6 edges>
gap> IsSymmetricDigraph(gr2);
false
gap> adj2 := AdjacencyMatrix(gr2);;
gap> Display(adj2);
[ [  0,  1,  1 ],
  [  1,  0,  1 ],
  [  0,  1,  1 ] ]
gap> adj2 = TransposedMat(adj2);
false
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>
