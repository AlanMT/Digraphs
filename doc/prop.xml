#############################################################################
##
#W  prop.xml
#Y  Copyright (C) 2014                                  James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="DigraphHasLoops">
<ManSection>
  <Prop Name="DigraphHasLoops" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    Returns <K>true</K> if the digraph <A>digraph</A> is has loops, and
    <K>false</K> if it does not. A loop is an edge with equal source and range.

    <Example><![CDATA[
gap> gr := Digraph( [ [ 1, 2 ], [ 2 ] ] );
<digraph with 2 vertices, 3 edges>
gap> DigraphEdges(gr);
[ [ 1, 1 ], [ 1, 2 ], [ 2, 2 ] ]
gap> DigraphHasLoops(gr);
true
gap> gr := Digraph( [ [ 2, 3 ], [ 1 ], [ 2 ] ] );
<digraph with 3 vertices, 4 edges>
gap> DigraphEdges(gr);
[ [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 3, 2 ] ]
gap> DigraphHasLoops(gr);
false
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsAcyclicDigraph">
<ManSection>
  <Prop Name="IsAcyclicDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    Returns <K>true</K> if the digraph <A>digraph</A> is acyclic and
    <K>false</K> if it is not. A digraph is <E>acyclic</E> if
    there are no cycles, i.e. paths starting and ending at the same vertex. <P/>

    The method used in this operation has complexity <M>O(m+n)</M> where
    <M>m</M> is the number of edges (counting multiple edges as one) and
    <M>n</M> is the number of vertices in the digraph. 

    <Example><![CDATA[
gap> Petersen := Graph( SymmetricGroup(5), [ [ 1, 2 ] ], OnSets,           
> function(x, y) return IsEmpty(Intersection(x, y)); end );;
gap> gr:=Digraph(Petersen);                    
<digraph with 10 vertices, 30 edges>
gap> IsAcyclicDigraph(gr);
false
gap> gr:=Digraph( [ [  ], [ 1 ], [ 1 ], [ 1 ], [ 3 ], [ 3 ], 
> [ 4 ], [ 4 ], [ 5 ], [ 5 ], [ 5 ], [ 6 ], [ 6 ], [ 7 ], [ 7 ], 
> [ 7 ], [ 8 ], [ 9 ], [ 9 ], [ 11 ], [ 11 ], [ 12 ], [ 12 ], [ 13 ], 
> [ 14 ], [ 15 ], [ 15 ], [ 16 ], [ 16 ], [ 17 ], [ 17 ], [ 18 ], 
> [ 18 ], [ 19 ], [ 20 ], [ 20 ], [ 21 ], [ 22 ], [ 22 ], [ 23 ], 
> [ 23 ], [ 24 ], [ 28 ], [ 29 ], [ 30 ], [ 30 ], [ 31 ], [ 32 ], 
> [ 32 ], [ 33 ], [ 34 ], [ 41 ], [ 46 ], [ 47 ], [ 51 ] ] );;
gap> IsAcyclicDigraph(gr);
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCompleteDigraph">
<ManSection>
  <Prop Name="IsCompleteDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    Returns <K>true</K> if the digraph <A>digraph</A> is complete, and 
    <K>false</K> if it is not. <P/>
    
    A digraph is <E>complete</E> if it has no loops, and for all
    <E>distinct</E> vertices <C>i</C> and <C>j</C>,
    there is exactly one edge with source <C>i</C> and range <C>j</C>.
    
    Equivalently, a digraph with <M>n</M> vertices is complete precisely when
    it has <M>n(n - 1)</M> edges, no loops, and no multiple edges.

    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 3 ], [ 1, 3 ], [ 1, 2 ] ] );
<digraph with 3 vertices, 6 edges>
gap> IsCompleteDigraph(gr);
true
gap> gr := Digraph( [ [ 2, 2 ], [ 1 ] ] );
<multidigraph with 2 vertices, 3 edges>
gap> IsCompleteDigraph(gr);
false
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsEmptyDigraph">
<ManSection>
  <Prop Name="IsEmptyDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    Returns <K>true</K> if the digraph <A>digraph</A> is empty, and
    <K>false</K> if it is not. A digraph is <E>empty</E> if it has no edges.

    <Example><![CDATA[
gap> gr := Digraph( [ [  ], [  ] ] );
<digraph with 2 vertices, 0 edges>
gap> IsEmptyDigraph(gr);
true
gap> gr := Digraph( [ [  ], [ 1 ] ] );
<digraph with 2 vertices, 1 edge>
gap> IsEmptyDigraph(gr);
false
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsFunctionalDigraph">
<ManSection>
  <Prop Name="IsFunctionalDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    This function returns <K>true</K> if the digraph <A>digraph</A> is
    functional. <P/>
    
    A digraph is <E>functional</E> if every vertex is the source of a
    unique edge. 
    <Example><![CDATA[
gap> gr1 := Digraph( [ [ 3 ], [ 2 ], [ 2 ], [ 1 ], [ 6 ], [ 5 ] ] );
<digraph with 6 vertices, 6 edges>
gap> IsFunctionalDigraph(gr1);
true
gap> gr2 := Digraph( [ [ 1, 2 ], [ 1 ] ] );
<digraph with 2 vertices, 3 edges>
gap> IsFunctionalDigraph(gr2);
false
gap> gr3 := Digraph( 3, [ 1, 2, 3 ], [ 2, 3, 1 ] );
<digraph with 3 vertices, 3 edges>
gap> IsFunctionalDigraph(gr3);
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsMultiDigraph">
<ManSection>
  <Prop Name="IsMultiDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    A <E>multidigraph</E> is one that has at least two 
    edges with equal source and range. 
    
    <Example><![CDATA[
gap> gr:=Digraph( [ "a", "b", "c" ],
> [ "a", "b", "b" ],
> [ "b", "c", "a" ] );
<digraph with 3 vertices, 3 edges>
gap> IsMultiDigraph(gr);
false
gap> gr := Digraph( 3, 
> [ 1, 2, 3, 1, 1, 2 ],
> [ 1, 2, 3, 2, 3, 1 ] );
<digraph with 3 vertices, 6 edges>
gap> IsMultiDigraph(gr);
false
gap> gr := Digraph( 3,
> [ 1, 2, 3, 1, 1, 2, 1 ],
> [ 1, 2, 3, 2, 3, 1, 2 ] );
<multidigraph with 3 vertices, 7 edges>
gap> IsMultiDigraph(gr);
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsReflexiveDigraph">
<ManSection>
  <Prop Name="IsReflexiveDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    This function returns <K>true</K> if the digraph <A>digraph</A> is 
    reflexive, and <K>false</K> if it is not.
    A digraph is <E>reflexive</E> if it has a loop at every vertex. <P/>
    <Example><![CDATA[
gap> gr := Digraph( [ [ 1, 2 ], [ 2 ] ] );
<digraph with 2 vertices, 3 edges>
gap> IsReflexiveDigraph(gr);
true
gap> gr := Digraph( rec ( nrvertices := 4,
> source := [ 1, 1, 2, 2, 3, 4, 4 ],
> range := [ 3, 1, 4, 2, 3, 2, 1 ] )  );
<digraph with 4 vertices, 7 edges>
gap> IsReflexiveDigraph(gr);
false
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsConnectedDigraph">
<ManSection>
  <Prop Name="IsConnectedDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    This function returns <K>true</K> if the directed graph <A>digraph</A>
    is weakly connected and <K>false</K> if it is not.  A directed graph
    <A>digraph</A> is <E>weakly connected</E> if it is possible to travel 
    from any vertex to any other vertex by traversing edges in either
    direction (possibly against the orientation of some of them). <P/>

    The method used in this function has complexity <M>O(m)</M> if the 
    digraph's Source attribute is set, otherwise it has complexity
    <M>O(m+n)</M> (where 
    <M>m</M> is the number of edges and
    <M>n</M> is the number of vertices of the digraph).

    <Example><![CDATA[
gap> gr := Digraph( [ [ 2 ], [ 3 ], [  ] ] );;
gap> IsConnectedDigraph(gr);
true
gap> gr := Digraph( [ [ 1, 3 ], [ 4 ], [ 3 ], [  ] ] );;
gap> IsConnectedDigraph(gr);
false]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsStronglyConnectedDigraph">
<ManSection>
  <Prop Name="IsStronglyConnectedDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    This function returns <K>true</K> if the directed graph <A>digraph</A> 
    is strongly connected and <K>false</K> if it is not.
    A directed graph <A>digraph</A> is <E>strongly connected</E> if there 
    is a path from every vertex to every other vertex. <P/>

    The method used in this operation is based on Gabow's Algorithm
    <Cite Key="Gabow2000aa"/> and has complexity <M>O(m+n)</M>,
    where <M>m</M> is the number of edges (counting multiple edges as one) 
    and <M>n</M> is the number of vertices in the digraph. 
  
    <Example><![CDATA[
gap> gr := CycleDigraph(250000);
<digraph with 250000 vertices, 250000 edges>
gap> IsStronglyConnectedDigraph(gr);
true
gap> gr:=DigraphRemoveEdges(gr, [ [ 250000, 1 ] ]);
<digraph with 250000 vertices, 249999 edges>
gap> IsStronglyConnectedDigraph(gr);
false
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSymmetricDigraph">
<ManSection>
  <Prop Name="IsSymmetricDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    This function returns <K>true</K> if the digraph <A>digraph</A> 
    is symmetric, and <K>false</K> if it is not.<P/>

    A <E>symmetric digraph</E> is one where for each non-loop edge,
    having source <M>u</M> and range <M>v</M>, there is a corresponding edge
    with source v and range u.
    If there are <M>n</M> edges with source <M>u</M>
    and range <M>v</M>, then there must be precisely <M>n</M> edges with 
    source <M>v</M> and range <M>u</M>.
    In other words, an undirected digraph has a symmetric adjacency 
    matrix <Ref Attr="AdjacencyMatrix"/>.<P/>
    <Example><![CDATA[
gap> gr1 := Digraph( [ [ 2 ], [ 1, 3 ], [ 2, 3 ] ] );
<digraph with 3 vertices, 5 edges>
gap> IsSymmetricDigraph(gr1);
true
gap> adj1 := AdjacencyMatrix(gr1);;
gap> Display(adj1);
[ [  0,  1,  0 ],
  [  1,  0,  1 ],
  [  0,  1,  1 ] ]
gap> adj1 = TransposedMat(adj1);
true
gap> gr2 := Digraph( [ [ 2, 3 ], [ 1, 3 ], [ 2, 3 ] ] );
<digraph with 3 vertices, 6 edges>
gap> IsSymmetricDigraph(gr2);
false
gap> adj2 := AdjacencyMatrix(gr2);;
gap> Display(adj2);
[ [  0,  1,  1 ],
  [  1,  0,  1 ],
  [  0,  1,  1 ] ]
gap> adj2 = TransposedMat(adj2);
false
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsAntisymmetricDigraph">
<ManSection>
  <Prop Name="IsAntisymmetricDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    This function returns <K>true</K> if the digraph <A>digraph</A> 
    is antisymmetric, and <K>false</K> if it is not. <P/>

    An <E>antisymmetric digraph</E> is one where for all vertices <C>u</C> and
    <C>v</C>, if there is an edge with source <C>u</C> and range <C>v</C>,
    and an edge with source <C>v</C> and range <C>u</C>, then the vertices
    <C>u</C> and <C>v</C> are equal. <P/>
    <Example><![CDATA[
gap> gr1 := Digraph( [ [ 2 ], [ 1, 3 ], [ 2, 3 ] ] );
<digraph with 3 vertices, 5 edges>
gap> IsAntisymmetricDigraph(gr1);
false
gap> DigraphEdges(gr1){[ 1, 2 ]};
[ [ 1, 2 ], [ 2, 1 ] ]
gap> gr2 := Digraph( [ [ 1, 2 ], [ 3, 3 ], [ 1 ] ] );
<multidigraph with 3 vertices, 5 edges>
gap> IsAntisymmetricDigraph(gr2);
true
gap> DigraphEdges(gr2);
[ [ 1, 1 ], [ 1, 2 ], [ 2, 3 ], [ 2, 3 ], [ 3, 1 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsTransitiveDigraph">
<ManSection>
  <Prop Name="IsTransitiveDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    This function returns <K>true</K> if the directed graph <A>digraph</A>
    is transitive, and <K>false</K> if it is not.
    
    A digraph is <E>transitive</E> if whenever <C>[ i, j ]</C> and 
    <C>[ j, k ]</C> are edges of the digraph, then <C>[ i, k ]</C> is also an
    edge of the digraph. <P/>

    Let <M>n</M> be the number of vertices of an arbitrary digraph, and let
        <M>m</M> be the number of edges.
    For general digraphs, the methods used in this function use a version
    of the Floyd-Warshall algorithm, and have complexity <M>O(n^3)</M>.

    However for digraphs which are topologically sortable
    [<Ref Attr="DigraphTopologicalSort"/>], then this function will 
    use methods with complexity <M>O(m + n + m \cdot n)</M> when appropriate.
    <P/>
    <Example><![CDATA[
gap> gr := Digraph( [ [ 1, 2 ], [ 3 ], [ 3 ] ] );
<digraph with 3 vertices, 4 edges>
gap> IsTransitiveDigraph(gr);
false
gap> gr2 := Digraph( [ [ 1, 2, 3 ], [ 3 ], [ 3 ] ] );
<digraph with 3 vertices, 5 edges>
gap> IsTransitiveDigraph(gr2);
true
gap> gr2 = DigraphTransitiveClosure(gr);
true
gap> gr3 := Digraph( [ [ 1, 2, 2, 3 ], [ 3, 3 ], [ 3 ] ] );
<multidigraph with 3 vertices, 7 edges>
gap> IsTransitiveDigraph(gr3);
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsTournament">
<ManSection>
  <Prop Name="IsTournament" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    Returns <K>true</K> if the directed graph <A>digraph</A> is a tournament,
    and <K>false</K> if it is not. <P/>
    
    A tournament is an orientation of a complete (undirected) graph.
    Specifically, a tournament is a digraph which has a unique directed edge
    (of some orientation) between any pair of distinct vertices, and no loops.
    <P/>
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 3, 4 ], [ 3, 4 ], [ 4 ], [  ] ] );
<digraph with 4 vertices, 6 edges>
gap> IsTournament(gr);
true
gap> gr := Digraph( [ [ 2 ], [ 1 ], [ 3 ] ] );
<digraph with 3 vertices, 3 edges>
gap> IsTournament(gr);
false
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsAperiodicDigraph">
<ManSection>
  <Prop Name="IsAperiodicDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    This function returns <K>true</K> if the directed graph <A>digraph</A>
    is aperiodic, i.e. if its <Ref Attr = "DigraphPeriod"/> is equal to 1. 
    <Example><![CDATA[
gap> gr := Digraph( [ [ 6 ], [ 1 ], [ 2 ], [ 3 ], [ 4, 4 ], [ 5 ] ] );
<multidigraph with 6 vertices, 7 edges>
gap> IsAperiodicDigraph(gr);
false
gap> gr := Digraph( [ [ 2 ], [ 3, 5 ], [ 4 ], [ 5 ], [ 1, 2 ] ] );
<digraph with 5 vertices, 7 edges>
gap> IsAperiodicDigraph(gr);
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>
