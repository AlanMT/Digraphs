#############################################################################
##
#W  attr.xml
#Y  Copyright (C) 2014                                  James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="AsGraph">
<ManSection>
  <Attr Name="AsGraph" Arg="digraph"/>
  <Returns></Returns>
  <Description>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphDual">
<ManSection>
  <Attr Name="DigraphDual" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph without multiple edges, then this
    function returns the <E>dual</E> of <A>digraph</A>. The <E>dual</E> is sometimes called the <E>complement</E>.<P/> 
    
    The <E>dual</E> of <A>digraph</A> has the same vertices as <A>digraph</A>,
    and there is an edge in the dual from <C>i</C> to <C>j</C>
    whenever there is no edge from <C>i</C> to <C>j</C> in <A>digraph</A>.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 3 ], [  ], [ 4, 6 ], [ 5 ], [  ],
> [ 7, 8, 9 ], [  ], [  ], [  ] ] );
<digraph with 9 vertices, 8 edges>
gap> DigraphDual(gr);
<digraph with 9 vertices, 73 edges>]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphTopologicalSort">
<ManSection>
  <Attr Name="DigraphTopologicalSort" Arg="digraph"/>
  <Returns>A list of positive integers, or <K>fail</K>.</Returns>
  <Description>
    If <A>digraph</A> is a digraph with no cycles of length greater than
    <M>1</M>, then this operation returns the vertices of <A>digraph</A> 
    ordered so that every vertex adjacent to <C>i</C> occurs before <C>i</C>. 
    If the digraph <A>digraph</A> contains cycles of length greater than 
    <M>1</M>, then this operation returns <K>fail</K>.
    <P/>

    The method used in this operation has complexity <M>O(m+n)</M> where
    <M>m</M> is the number of edges (counting multiple edges as one) and
    <M>n</M> is the number of vertices in the digraph. <P/> 
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2, 3 ], [  ], [ 4, 6 ], [ 5 ], [  ], [ 7, 8, 9 ], [  ],
> [  ], [  ] ] );
<digraph with 9 vertices, 8 edges>
gap> DigraphTopologicalSort(gr);
[ 2, 5, 4, 7, 8, 9, 6, 3, 1 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="AdjacencyMatrix">
<ManSection>
  <Attr Name="AdjacencyMatrix" Arg="digraph"/>
  <Returns>A square matrix of non-negative integers.</Returns>
  <Description>
    This function returns the adjacency matrix <C>mat</C> of the digraph 
    <A>digraph</A>.
    The value of the matrix entry <C>mat[i][j]</C> is the number of edges 
    in <A>digraph</A> with source <C>i</C> and range <C>j</C>.
    
    <Example><![CDATA[
gap> gr:=Digraph( [ [ 2, 2, 2 ], [ 1, 3, 6, 8, 9, 10 ], [ 4, 6, 8 ],
> [ 1, 2, 3, 9 ], [ 3, 3 ], [ 3, 5, 6, 10 ], [ 1, 2, 7 ],
> [ 1, 2, 3, 10, 5, 6, 10 ], [ 1, 3, 4, 5, 8, 10 ], 
> [ 2, 3, 4, 6, 7, 10 ] ] );
<multidigraph with 10 vertices, 44 edges>
gap> mat := AdjacencyMatrix(gr);;
gap> Display(mat);
[ [  0,  3,  0,  0,  0,  0,  0,  0,  0,  0 ],
  [  1,  0,  1,  0,  0,  1,  0,  1,  1,  1 ],
  [  0,  0,  0,  1,  0,  1,  0,  1,  0,  0 ],
  [  1,  1,  1,  0,  0,  0,  0,  0,  1,  0 ],
  [  0,  0,  2,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  1,  0,  1,  1,  0,  0,  0,  1 ],
  [  1,  1,  0,  0,  0,  0,  1,  0,  0,  0 ],
  [  1,  1,  1,  0,  1,  1,  0,  0,  0,  2 ],
  [  1,  0,  1,  1,  1,  0,  0,  1,  0,  1 ],
  [  0,  1,  1,  1,  0,  1,  1,  0,  0,  1 ] ]]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="RangeSourceDigraph">
<ManSection>
  <Attr Name="DigraphRange" Arg="digraph"/>
  <Attr Name="DigraphSource" Arg="digraph"/>
  <Returns>A list of positive integers.</Returns>
  <Description>
    <C>DigraphRange</C> and <C>DigraphSource</C> return the range and source of
    the directed graph <A>digraph</A>. More precisely, position <C>i</C> in
    <C>DigraphRange(<A>digraph</A>)</C> is the range of the <C>i</C>th edge of
    <A>digraph</A>. 

    <Example><![CDATA[
gap> gr := Digraph( [ [ 1, 2, 3, 5 ], [ 1, 3, 4 ], [ 2, 3 ], 
> [ 2 ], [ 1, 2, 3, 4 ] ] );
<digraph with 5 vertices, 14 edges>
gap> DigraphRange(gr);
[ 1, 2, 3, 5, 1, 3, 4, 2, 3, 2, 1, 2, 3, 4 ]
gap> DigraphSource(gr);
[ 1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 5, 5, 5, 5 ]
gap> DigraphEdges(gr);
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 5 ], [ 2, 1 ], [ 2, 3 ], 
  [ 2, 4 ], [ 3, 2 ], [ 3, 3 ], [ 4, 2 ], [ 5, 1 ], [ 5, 2 ], 
  [ 5, 3 ], [ 5, 4 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphEdges">
<ManSection>
  <Attr Name="DigraphEdges" Arg="digraph"/>
  <Returns>The edges of a digraph.</Returns>
  <Description>
    Returns the list of edges of the directed graph <A>digraph</A>,
    that is, a list of pairs of elements of <Ref Oper="DigraphVertices"/>.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 1, 3, 4, 3, 5 ], [ 1, 2, 3, 5 ], [ 2, 4, 5 ], 
> [ 2, 4, 5 ], [ 1 ] ] );
<multidigraph with 5 vertices, 16 edges>
gap> DigraphEdges(gr);
[ [ 1, 1 ], [ 1, 3 ], [ 1, 4 ], [ 1, 3 ], [ 1, 5 ], [ 2, 1 ], 
  [ 2, 2 ], [ 2, 3 ], [ 2, 5 ], [ 3, 2 ], [ 3, 4 ], [ 3, 5 ], 
  [ 4, 2 ], [ 4, 4 ], [ 4, 5 ], [ 5, 1 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphNrEdges">
<ManSection>
  <Attr Name="DigraphNrEdges" Arg="digraph"/>
  <Returns>The number of edges of a digraph.</Returns>
  <Description>
    This function returns the number of edges of the digraph <A>digraph</A>.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 1, 3, 4, 5 ], [ 1, 2, 3, 5 ], [ 2, 4, 5 ], 
> [ 2, 4, 5 ], [ 1 ] ] );;
gap> DigraphNrEdges(gr);
15
gap> gr := Digraph( [ "a", "b", "c" ],
> [ "a", "b", "b" ],
> [ "b", "a", "a" ] );
<multidigraph with 3 vertices, 3 edges>
gap> DigraphNrEdges(gr);
3]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="OutNeighbours">
<ManSection>
  <Attr Name="OutNeighbours" Arg="digraph"/>
  <Attr Name="OutNeighbors" Arg="digraph"/>
  <Oper Name="OutNeighboursCopy" Arg="digraph"/>
  <Oper Name="OutNeighborsCopy" Arg="digraph"/>
  <Returns>The adjacencies of a digraph.</Returns>
  <Description>
    This function returns the list <C>out</C> of out-neighbours of each vertex
    of the digraph <A>digraph</A>.
    More specifically, a vertex <C>j</C> appears in <C>out[i]</C> each time
    there exists an edge with source <C>i</C> and range <C>j</C> in 
    <A>digraph</A>. <P/>

    The function <C>OutNeighbours</C> returns an immutable list of immutable 
    lists, whereas the function <C>OutNeighboursCopy</C> returns a copy of
    <C>OutNeighbours</C> which is a mutable list of mutable lists. <P/>
    <Example><![CDATA[
gap> gr := Digraph( [ "a", "b", "c" ],
> [ "a", "b", "b" ],
> [ "b", "a", "c" ] );
<digraph with 3 vertices, 3 edges>
gap> OutNeighbours(gr);
[ [ 2 ], [ 1, 3 ], [  ] ]
gap> gr := Digraph( 3, 
> [ 1, 2, 3, 1, 1, 2 ],
> [ 1, 2, 3, 2, 3, 1 ] );
<digraph with 3 vertices, 6 edges>
gap> OutNeighbours(gr);
[ [ 1, 2, 3 ], [ 2, 1 ], [ 3 ] ]
gap> gr := Digraph( 3,
> [ 1, 2, 3, 1, 1, 2, 1 ],
> [ 1, 2, 3, 2, 3, 1, 2 ] );
<multidigraph with 3 vertices, 7 edges>
gap> OutNeighbours(gr);
[ [ 1, 2, 3, 2 ], [ 2, 1 ], [ 3 ] ]
gap> OutNeighboursCopy(gr);
[ [ 1, 2, 3, 2 ], [ 2, 1 ], [ 3 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="InNeighbours">
<ManSection>
  <Attr Name="InNeighbours" Arg="digraph"/>
  <Attr Name="InNeighbors" Arg="digraph"/>
  <Returns>A list of lists of vertices.</Returns>
  <Description>
    This function returns the list <C>inn</C> of in-neighbours of each vertex
    of the digraph <A>digraph</A>.
    More specifically, a vertex <C>j</C> appears in <C>inn[i]</C> each time
    there exists an edge with source <C>j</C> and range <C>i</C> in
    <A>digraph</A>. <P/>
    
    Note that each entry of <C>inn</C> is sorted into ascending order. <P/>

    <Example><![CDATA[
gap> gr := Digraph( [ "a", "b", "c" ],
> [ "a", "b", "b" ],
> [ "b", "a", "c" ] );
<digraph with 3 vertices, 3 edges>
gap> InNeighbours(gr);
[ [ 2 ], [ 1 ], [ 2 ] ]
gap> gr := Digraph( 3, 
> [ 1, 2, 3, 1, 1, 2 ],
> [ 1, 2, 3, 2, 3, 1 ] );
<digraph with 3 vertices, 6 edges>
gap> InNeighbours(gr);
[ [ 1, 2 ], [ 1, 2 ], [ 1, 3 ] ]
gap> gr := Digraph( 3,
> [ 1, 2, 3, 1, 1, 2, 1 ],
> [ 1, 2, 3, 2, 3, 1, 2 ] );
<multidigraph with 3 vertices, 7 edges>
gap> InNeighbours(gr);
[ [ 1, 2 ], [ 1, 1, 2 ], [ 1, 3 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="OutDegrees">
<ManSection>
  <Attr Name="OutDegrees" Arg="digraph"/>
  <Attr Name="OutDegreeSequence" Arg="digraph"/>
  <Returns>A list of non-negative integers.</Returns>
  <Description>

    Given a directed graph <A>digraph</A> with <M>n</M> vertices, the function
    <C>OutDegrees</C> returns a list <C>out</C> of length <M>n</M>, such that 
    for a vertex <C>i</C> in <A>digraph</A>, the value of <C>out[i]</C> is the 
    out-degree of vertex <C>i</C>.
    See <Ref Oper="OutDegreeOfVertex"/>. <P/>

    The function <C>OutDegreeSequence</C> returns the same list,
    after it has been sorted into non-increasing order.

    <Example><![CDATA[
gap> gr := Digraph( [ [ 1, 3, 2, 2 ], [ ], [ 2, 1 ] ] );
<multidigraph with 3 vertices, 6 edges>
gap> OutDegrees(gr);
[ 4, 0, 2 ]
gap> OutDegreeSequence(gr);
[ 4, 2, 0 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="InDegrees">
<ManSection>
  <Attr Name="InDegrees" Arg="digraph"/>
  <Attr Name="InDegreeSequence" Arg="digraph"/>
  <Returns>A list of non-negative integers.</Returns>
  <Description>

    Given a directed graph <A>digraph</A> with <M>n</M> vertices, the function
    <C>InDegrees</C> returns a list <C>inn</C> of length <M>n</M>, such that 
    for a vertex <C>i</C> in <A>digraph</A>, the value of <C>inn[i]</C> is 
    the in-degree of vertex <C>i</C>.
    See <Ref Oper="InDegreeOfVertex"/>. <P/>

    The function <C>InDegreeSequence</C> returns the same list, 
    after it has been sorted into non-increasing order.

    <Example><![CDATA[
gap> gr := Digraph( [ [ 1, 3, 2, 2 ], [ ], [ 2, 1 ] ] );
<multidigraph with 3 vertices, 6 edges>
gap> InDegrees(gr);
[ 2, 3, 1 ]
gap> InDegreeSequence(gr);
[ 3, 2, 1 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphVertices">
<ManSection>
  <Attr Name="DigraphVertices" Arg="digraph"/>
  <Returns>The vertices of a digraph.</Returns>
  <Description>
    Returns the vertices of the digraph <A>digraph</A>. <P/>

    <B>Note that:</B> the vertices of a digraph are always a range of
    positive integers from <C>1</C> to the number of vertices of the graph. 
    <Example><![CDATA[
gap> gr := Digraph( [ "a", "b", "c" ],
> [ "a", "b", "b" ],
> [ "b", "c", "a" ] );
<digraph with 3 vertices, 3 edges>
gap> DigraphVertices(gr);
[ 1 .. 3 ]
gap> gr := Digraph( [ 1, 2, 3, 4, 5, 7 ],
> [ 1, 2, 2, 4, 4 ],
> [ 2, 3, 5, 3, 5 ] );
<digraph with 6 vertices, 5 edges>
gap> DigraphVertices(gr);
[ 1 .. 6 ]
gap> DigraphVertices(RandomDigraph(100));
[ 1 .. 100 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphNrVertices">
<ManSection>
  <Attr Name="DigraphNrVertices" Arg="digraph"/>
  <Returns>The number of vertices of a digraph.</Returns>
  <Description>
    Returns the number of vertices of the digraph <A>digraph</A>. <P/>

    <Example><![CDATA[
gap> gr := Digraph( [ "a", "b", "c" ],
> [ "a", "b", "b" ],
> [ "b", "c", "a" ] );
<digraph with 3 vertices, 3 edges>
gap> DigraphNrVertices(gr);
3
gap> gr := Digraph( [ 1, 2, 3, 4, 5, 7 ],
> [ 1, 2, 2, 4, 4 ], 
> [ 2, 3, 5, 3, 5 ] );
<digraph with 6 vertices, 5 edges>
gap> DigraphNrVertices(gr);
6
gap> DigraphNrVertices(RandomDigraph(100));
100]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphStronglyConnectedComponents">
<ManSection>
  <Attr Name="DigraphStronglyConnectedComponents" Arg="digraph"/>
  <Returns>A record.</Returns>
  <Description>
    This function returns the record <C>scc</C> corresponding to the 
    strongly connected components of the directed graph <A>digraph</A>.
    Two vertices of <A>digraph</A> are in the same strongly connected
    component whenever there is a path from each vertex to the other.
    The set of strongly connected components is a partition of
    the vertex set of <A>digraph</A>. <P/>

    The record <C>scc</C> has 2 components: <C>comps</C> and <C>id</C>.
    The component <C>comps</C> is a list of the strongly connected components
    of <A>digraph</A> (each of which is a list of vertices).
    The component <C>id</C> is a list such that the vertex <C>i</C> is an
    element of the strongly connected component <C>comps[id[i]]</C>. <P/>

    The method used in this function is a non-recursive version of Gabow's
    Algorithm <Cite Key="Gabow2000aa"/> and has complexity <M>O(m+n)</M> where
    <M>m</M> is the number of edges (counting multiple edges as one) and
    <M>n</M> is the number of vertices in the digraph. 
    
    <Example><![CDATA[
gap> gr := Digraph( [ "a", "b", "c" ],
> [ "a", "b", "b" ],
> [ "b", "c", "a" ] );
<digraph with 3 vertices, 3 edges>
gap> DigraphStronglyConnectedComponents(gr);
rec( comps := [ [ 3 ], [ 1, 2 ] ], id := [ 2, 2, 1 ] )
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

#

<#GAPDoc Label="DigraphConnectedComponents">
<ManSection>
  <Attr Name="DigraphConnectedComponents" Arg="digraph"/>
  <Returns>A record.</Returns>
  <Description>
    This function returns the record <C>wcc</C> corresponding to the weakly 
    connected components of the digraph <A>digraph</A>.
    Two vertices of <A>digraph</A> are in the same weakly connected 
    component whenever there exists a path (ignoring the orientation
    of edges) between them.
    The set of weakly connected components is a partition of
    the vertex set of <A>digraph</A>. <P/>

    The record <C>wcc</C> has 2 components: <C>comps</C> and <C>id</C>.
    The component <C>comps</C> is a list of the weakly connected components
    of  <A>digraph</A> (each of which is a list of vertices).
    The component <C>id</C> is a list such that the vertex <C>i</C> is an 
    element of the weakly connected component <C>comps[id[i]]</C>. <P/>

    The method used in this function has complexity  <M>O(m+n)</M>, where
    <M>m</M> is the number of edges and
    <M>n</M> is the number of vertices in the digraph. 
    
    <Example><![CDATA[
gap> gr := Digraph( [ "a", "b", "c" ],
> [ "a", "b", "b" ], 
> [ "b", "c", "a" ] );
<digraph with 3 vertices, 3 edges>
gap> DigraphConnectedComponents(gr);
rec( comps := [ [ 1, 2, 3 ] ], id := [ 1, 1, 1 ] )
gap> gr := Digraph( [ [ 1 ], [ 1, 2 ], [  ] ] );
<digraph with 3 vertices, 3 edges>
gap> DigraphConnectedComponents(gr);
rec( comps := [ [ 1, 2 ], [ 3 ] ], id := [ 1, 1, 2 ] )
gap> gr := Digraph( [ ] );
<digraph with 0 vertices, 0 edges>
gap> DigraphConnectedComponents(gr);
rec( comps := [  ], id := [  ] )
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

#

<#GAPDoc Label="DigraphShortestDistances">
<ManSection>
  <Attr Name="DigraphShortestDistances" Arg="digraph"/>
  <Returns>A square matrix of integers.</Returns>
  <Description>
    If <A>digraph</A> is a digraph with <M>n</M> vertices, then this 
    function returns an <M>n \times n</M> matrix of integers <C>mat</C>.
    
    If a directed path from vertex <C>i</C> to vertex <C>j</C> exists,
    then the value of <C>mat[i][j]</C> is the length of the shortest such 
    path. In particular <C>mat[i][i] = 0</C> for all vertices <C>i</C>,
    using a directed path of length zero.
    <P/>
    
    If no such path exists, then the value of <C>mat[i][j]</C> is <C>-1</C>.
    If <M>n = 0</M>, then an empty list is returned. <P/>

    The method used in this function is a version of the Floyd-Warshall 
    algorithm, and has complexity <M>O(n^3)</M>.
    
    <Example><![CDATA[
gap> gr := Digraph( [ [ 1, 2 ], [ 3 ], [ 1, 2 ], [ 4 ] ] );
<digraph with 4 vertices, 6 edges>
gap> mat := DigraphShortestDistances(gr);;
gap> Display(mat);
[ [   0,   1,   2,  -1 ],
  [   2,   0,   1,  -1 ],
  [   1,   1,   0,  -1 ],
  [  -1,  -1,  -1,   0 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

#

<#GAPDoc Label="DigraphSinks">
<ManSection>
  <Attr Name="DigraphSinks" Arg="digraph"/>
  <Returns>A list of vertices.</Returns>
  <Description>
    This function returns a list of the sinks of the directed graph
    <A>digraph</A>.
    A sink of a digraph is a vertex with out-degree zero.
    See <Ref Oper="OutDegreeOfVertex"/>.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 3, 5, 2, 2 ], [ 3 ], [  ], [ 5, 2, 5, 3 ], [  ] ] );
<multidigraph with 5 vertices, 9 edges>
gap> DigraphSinks(gr);
[ 3, 5 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphSources">
<ManSection>
  <Attr Name="DigraphSources" Arg="digraph"/>
  <Returns>A list of vertices.</Returns>
  <Description>
    This function returns a list of the sources of the directed graph 
    <A>digraph</A>.
    A source of a digraph is a vertex with in-degree zero.
    See <Ref Oper="InDegreeOfVertex"/>.
    <Example><![CDATA[
gap> gr := Digraph( [ [ 3, 5, 2, 2 ], [ 3 ], [  ], [ 5, 2, 5, 3 ], [  ] ] );
<multidigraph with 5 vertices, 9 edges>
gap> DigraphSources(gr);
[ 1, 4 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphPeriod">
<ManSection>
  <Attr Name="DigraphPeriod" Arg="digraph"/>
  <Returns>An integer.</Returns>
  <Description>
    This function returns the period of the directed graph <A>digraph</A>.<P/>

    If a directed graph <A>digraph</A> has at least one cycle, then the
    period is the greatest positive integer which divides the lengths of all 
    cycles of <A>digraph</A>.
    If <A>digraph</A> has no cycles, then this function returns <M>0</M>.<P/>
    
    A digraph with a period of <M>1</M> is said to be <E>aperiodic</E>.
    See <Ref Prop="IsAperiodicDigraph"/>. <P/>
    <Example><![CDATA[
gap> gr := Digraph( [ [ 6 ], [ 1 ], [ 2 ], [ 3 ], [ 4, 4 ], [ 5 ] ] );
<multidigraph with 6 vertices, 7 edges>
gap> DigraphPeriod(gr);
6
gap> gr := Digraph( [ [ 2 ], [ 3, 5 ], [ 4 ], [ 5 ], [ 1, 2 ] ] );
<digraph with 5 vertices, 7 edges>
gap> DigraphPeriod(gr);
1
gap> gr := Digraph( [ [ 2 ], [ ] ] );
<digraph with 2 vertices, 1 edge>
gap> DigraphPeriod(gr);
0
gap> IsAcyclicDigraph(gr);
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphDiameter">
<ManSection>
  <Attr Name="DigraphDiameter" Arg="digraph"/>
  <Returns>An integer.</Returns>
  <Description>
    This function returns the diameter of the directed graph <A>digraph</A>.<P/>

    If a directed graph <A>digraph</A> is strongly connected,
    then the diameter is the maximum shortest distance between any 
    pair of vertices. Otherwise, or if <A>digraph</A> has no vertices,
    then the diameter of <A>digraph</A>
    is undefined, and this function returns the value <C>-1</C>. <P/>
    
    See <Ref Attr="DigraphShortestDistances"/>. <P/>
    <Example><![CDATA[
gap> gr := Digraph( [ [ 2 ], [ 3 ], [ 4, 5 ], [ 5 ], 
> [ 1, 2, 3, 4, 5 ] ] );
<digraph with 5 vertices, 10 edges>
gap> DigraphDiameter(gr);
3
gap> gr := Digraph( [ [ 2 ], [  ] ] );
<digraph with 2 vertices, 1 edge>
gap> DigraphDiameter(gr);
-1
gap> IsStronglyConnectedDigraph(gr);
false
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="ReducedDigraph">
<ManSection>
  <Attr Name="ReducedDigraph" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    This function returns a digraph isomorphic to the subdigraph of 
    <A>digraph</A> induced by the set of non-isolated vertices,
    i.e. the set of those vertices of <A>digraph</A> which are the source or 
    range of some edge in <A>digraph</A>.
    See <Ref Oper="InducedSubdigraph"/>.
    <P/>
    
    The vertex labels and edge
    labels of the graph are preserved, so that a vertex in the new digraph can
    be matched to the corresponding vertex in <A>digraph</A>.<P/>
    <Log><![CDATA[
gap> d := Digraph([ [ 1, 2 ], [  ], [  ], [ 1, 4 ], [  ] ]);
<digraph with 5 vertices, 4 edges>
gap> r := ReducedDigraph(d);
<digraph with 3 vertices, 4 edges>
gap> OutNeighbours(r);
[ [ 1, 3 ], [ 1, 2 ], [  ] ]
gap> DigraphEdges(r); DigraphEdges(d);
[ [ 1, 1 ], [ 1, 3 ], [ 2, 1 ], [ 2, 2 ] ]
[ [ 1, 1 ], [ 1, 2 ], [ 4, 1 ], [ 4, 4 ] ]
gap> DigraphVertexLabel(r, 3);
2
gap> DigraphVertexLabel(r, 2);
4
]]></Log>
  </Description>
</ManSection>
<#/GAPDoc>
