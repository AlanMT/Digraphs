##
#W  digraph.xml
#Y  Copyright (C) 2014                                  James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="IsDigraph">
<ManSection>
  <Filt Name="IsDigraph" Type='Category'/>
  <Description>
    Every  digraph in  &Digraphs;  belongs  to  the  category
    <C>IsDigraph</C>.  Basic attributes and operations for digraphs
    are: <Ref Oper="DigraphVertices"/>, <Ref Attr="DigraphRange"/>, <Ref
      Attr="DigraphSource"/>, <Ref Attr="OutNeighbours"/>, and <Ref
      Attr="DigraphEdges"/>. 
    </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="Digraph">
<ManSection>
  <Oper Name="Digraph" Arg="obj[, source, range]"/>
  <Returns>A digraph.</Returns>
  <Description>
    <List>
      <Mark>for a list</Mark>
      <Item>
        if <A>obj</A> is a list of lists of positive integers in
        the range from <C>1</C> to <C>Length(<A>obj</A>)</C>, then this function
        returns the digraph with vertices
        <M>E^0=</M><C>[1..Length(<A>obj</A>)]</C>,
        and edges corresponding to the entries of <A>obj</A>.
        More precisely, there is an edge from vertex <C>i</C> to <C>j</C> if
        <C>j</C> is in <C><A>obj</A>[i]</C>; the source of this edge is
        <C>i</C> and the range is <C>j</C>. If <C>j</C> occurs multiple
        times in <C><A>obj</A>[i]</C>, then there are multiple edges from
        <C>i</C> to <C>j</C>.
      </Item>

      <Mark>for three lists</Mark>
      <Item>
        if <A>obj</A>, <A>source</A>, and <A>range</A> are lists, and
        <A>obj</A> is duplicate-free,
        then this function returns the directed graph with vertices 
        <M>E^0=</M><C>[1..Length(<A>obj</A>)]</C>,
        edges indexed by
        <C>[1..Length(<A>source</A>)]</C>, and
        source and range functions defined by <A>source</A> and
        <A>range</A>.  The lists <A>source</A> and
        <A>range</A> must have equal length and consist of
        elements of <A>obj</A>.
        The vertices of the digraph will be be labelled by the elements of
        <A>obj</A>.
      </Item>

      <Mark>for an integer, and two lists</Mark>
      <Item>
        if <A>obj</A> is a non-negative integer and
        <A>source</A> and <A>range</A> are lists,
        then this function returns the directed graph with vertices 
        <M>E^0=</M><C>[1..<A>obj</A>]</C>,
        edges indexed by
        <C>[1..Length(<A>source</A>)]</C>, and
        source and range functions defined by <A>source</A> and
        <A>range</A>. The lists <A>source</A> and
        <A>range</A> must have equal length and consist of
        positive integers in the list <C>[1..<A>obj</A>]</C>.  
      </Item>

      <Mark>for a Grape package graph</Mark>
      <Item>
        if <A>obj</A> is a &Grape; package graph (i.e. a record for which the
        function <C>IsGraph</C> returns <K>true</K>), then this function returns
        a digraph isomorphic to <A>obj</A>.
      </Item>

      <Mark>for a binary relation</Mark>
      <Item>
        if <A>obj</A> is a binary relation on the points <C>[1..n]</C> for
        some posititve integer <M>n</M>, then this function returns the digraph
        defined by <A>obj</A>. Specifically, this function returns a digraph
        which has <M>n</M> vertices, and which has an edge with source <C>i</C>
        and range <C>j</C> if and only if <C>i</C> is related to <C>j</C> in
        the binary relation <A>obj</A>.
      </Item>

    </List>
  
    <Example><![CDATA[
gap> gr:= Digraph( [ [ 2, 5, 8, 10 ], [ 2, 3, 4, 2, 5, 6, 8, 9, 10 ], 
> [ 1 ], [ 3, 5, 7, 8, 10 ], [ 2, 5, 7 ], [ 3, 6, 7, 9, 10 ], [ 1, 4 ],
> [ 1, 5, 9 ], [ 1, 2, 7, 8 ], [ 3, 5 ] ] );
<multidigraph with 10 vertices, 38 edges>
gap> gr := Digraph( [ "a", "b", "c" ], [ "a" ], [ "b" ] );
<digraph with 3 vertices, 1 edge>
gap> gr := Digraph( 5, [ 1, 2, 2, 4, 1, 1 ], [ 2, 3, 5, 5, 1, 1 ] );
<multidigraph with 5 vertices, 6 edges>
gap> Petersen := Graph( SymmetricGroup(5), [ [ 1, 2 ] ], OnSets,
> function(x, y) return Intersection(x, y) = [ ]; end );;
gap> Digraph(Petersen);
<digraph with 10 vertices, 30 edges>
gap> b := BinaryRelationOnPoints(
> [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ], [ 2, 3, 5 ] ] );
Binary Relation on 5 points
gap> gr := Digraph(b);
<digraph with 5 vertices, 11 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="GrapeGraph">
<ManSection>
  <Oper Name="Graph" Arg="digraph"/>
  <Returns>A <Package>Grape</Package> package graph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph, then this method returns a &Grape;
    package graph, that is isomorphic to <A>digraph</A>.
    
    <Example><![CDATA[
gap> Petersen := Graph( SymmetricGroup(5), [[1,2]], OnSets,
> function(x,y) return Intersection(x,y)=[]; end );
Graph( rec(
  adjacencies := [ [ 3, 5, 8 ] ],
  group := 
   Group( [ ( 1, 2, 3, 5, 7)( 4, 6, 8, 9,10), ( 2, 4)( 6, 9)( 7,10) 
     ] ),
  isGraph := true,
  order := 10,
  representatives := [ 1 ],
  schreierVector := [ -1, 1, 1, 2, 1, 1, 1, 1, 2, 2 ],
  names := [ [ 1, 2 ], [ 2, 3 ], [ 3, 4 ], [ 1, 3 ], [ 4, 5 ], 
      [ 2, 4 ], [ 1, 5 ], [ 3, 5 ], [ 1, 4 ], [ 2, 5 ] ] ))
gap> Digraph(Petersen);
<digraph with 10 vertices, 30 edges>
gap> Graph(last);
Graph( rec(
  adjacencies := 
   [ [ 3, 5, 8 ], [ 5, 7, 9 ], [ 1, 7, 10 ], [ 5, 6, 10 ], 
      [ 1, 2, 4 ], [ 4, 7, 8 ], [ 2, 3, 6 ], [ 1, 6, 9 ], 
      [ 2, 8, 10 ], [ 3, 4, 9 ] ],
  group := Group( [ () ] ),
  isGraph := true,
  order := 10,
  representatives := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ],
  schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10 ],
  names := [ 1 .. 10 ] ))
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphByAdjacencyMatrix">
<ManSection>
  <Oper Name="DigraphByAdjacencyMatrix" Arg="adj"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>adj</A> is the adjacency matrix of a digraph, in the sense of
    <Ref Attr="AdjacencyMatrix"/>, then this function returns the directed 
    graph which is defined by <A>adj</A>.
    <Example><![CDATA[
gap> DigraphByAdjacencyMatrix( [
> [ 0, 1, 0, 2, 0 ],
> [ 1, 1, 1, 0, 1 ],
> [ 0, 3, 2, 1, 1 ],
> [ 0, 0, 1, 0, 1 ],
> [ 2, 0, 0, 0, 0 ] ]);
<multidigraph with 5 vertices, 18 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphByEdges">
<ManSection>
  <Oper Name="DigraphByEdges" Arg="edges[, n]"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>edges</A> is list of pairs of positive integers, then this function
    returns the digraph with the minimum number of vertices such that its
    edges equal <A>edges</A>.<P/>

    If the optional second argument <A>n</A> is a positive integer, then this
    function returns the digraph with <A>n</A> vertices and edges
    <A>edges</A>. 
    
    <Example><![CDATA[
gap> DigraphByEdges( 
> [ [ 1, 3 ], [ 2, 1 ], [ 2, 3 ], [ 2, 5 ], [ 3, 6 ], 
>   [ 4, 6 ], [ 5, 2 ], [ 5, 4 ], [ 5, 6 ], [ 6, 6 ] ]);
<digraph with 6 vertices, 10 edges>
gap> DigraphByEdges( 
> [ [ 1, 3 ], [ 2, 1 ], [ 2, 3 ], [ 2, 5 ], [ 3, 6 ], 
>   [ 4, 6 ], [ 5, 2 ], [ 5, 4 ], [ 5, 6 ], [ 6, 6 ] ], 10);
<digraph with 10 vertices, 10 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphByInNeighbours">
<ManSection>
  <Oper Name="DigraphByInNeighbours" Arg="in"/>
  <Oper Name="DigraphByInNeighbors" Arg="in"/>
  <Returns>A digraph.</Returns>
  <Description>

  If <A>in</A> is a list of lists of positive integers in the range 
  <C>[1..Length(<A>in</A>)]</C>, then this function returns the
  digraph with vertices <M>E^0=</M><C>[1..Length(<A>in</A>)]</C>, and 
  edges corresponding to the entries of <A>in</A>. More precisely, there is an 
  with source vertex <C>i</C> and range vertex <C>j</C> if <C>i</C> is in 
  <C><A>in</A>[j]</C>. <P/>

  If <C>i</C> occurs multiple times in <C><A>in</A>[j]</C>, then there are 
  multiple edges from <C>i</C> to <C>j</C>.

    <Example><![CDATA[
gap> gr := DigraphByInNeighbours( [
> [ 2, 5, 8, 10 ], [ 2, 3, 4, 5, 6, 8, 9, 10 ], 
> [ 1 ], [ 3, 5, 7, 8, 10 ], [ 2, 5, 7 ], [ 3, 6, 7, 9, 10 ], [ 1, 4 ], 
> [ 1, 5, 9 ], [ 1, 2, 7, 8 ], [ 3, 5 ] ] );
<digraph with 10 vertices, 37 edges>
gap> gr := DigraphByInNeighbours( [ [ 2, 3, 2 ], [ 1 ], [ 1, 2, 3 ] ] );
<multidigraph with 3 vertices, 7 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="AsDigraph">
<ManSection>
  <Oper Name="AsDigraph" Arg="trans[, n]"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>trans</A> is transformation and <A>n</A> is a non-negative integer,
    then this function returns the functional digraph with <A>n</A> 
    vertices defined by <A>trans</A>. See <Ref Prop="IsFunctionalDigraph"/>.
    
    Specifically, the graph has  <A>n</A> edges: for each vertex <M>x</M>, 
    there is a unique edge with source <M>x</M>; this edge has range 
    <M>x</M>^<A>trans</A>.
    <P/>

    If the optional second argument <A>n</A> is not supplied, then the degree
    of the transformation <A>trans</A> is used by default.
    
    <Example><![CDATA[
gap> f := Transformation( [ 7, 10, 10, 1, 7, 9, 10, 4, 2, 3 ] );
Transformation( [ 7, 10, 10, 1, 7, 9, 10, 4, 2, 3 ] )
gap> AsDigraph(f); 
<digraph with 10 vertices, 10 edges>
gap> AsDigraph(f, 4); 
<digraph with 4 vertices, 4 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="RandomDigraph">
<ManSection>
  <Oper Name="RandomDigraph" Arg="n[, p]"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>n</A> is a positive integer, then this function returns a random 
    digraph with <A>n</A> vertices and without multiple edges. <P/>

    If the optional second argument <A>p</A> is a float with value 
    <M>0 \leq <A> p </A> \leq 1</M>, then an edge will exist between each 
    pair of vertices with probability approximately <A>p</A>.
    If <A>p</A> is not specified, then a random probability will be assumed
    (chosen with uniform probability).
    <Log><![CDATA[
gap> RandomDigraph(1000);
<digraph with 1000 vertices, 364444 edges>
gap> RandomDigraph(10000, 0.023);
<digraph with 10000 vertices, 2300438 edges>
]]></Log>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="RandomMultiDigraph">
<ManSection>
  <Oper Name="RandomMultiDigraph" Arg="n[, m]"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>n</A> is a positive integer, then this function returns a random 
    digraph with <A>n</A> vertices. If the optional second argument 
    <A>m</A> is a positive integer, then the digraph will have <A>m</A>
    edges. If <A>m</A> is not specified, then the number of edges will be
    chosen randomly (with uniform probability) from the range 
    <C>[ 1 .. </C><M>{n \choose 2}</M><C> ]</C>.
    <P/>

    The method used by this function chooses each edge from the set of 
    all possible edges with uniform probability. No effort is made to avoid
    creating multiple edges, so it is likely (but not guaranteed) that the
    result will have multiple edges. <P/>
    <Log><![CDATA[
gap> RandomMultiDigraph(1000);
<multidigraph with 1000 vertices, 216659 edges>
gap> RandomMultiDigraph(1000, 950);
<multidigraph with 1000 vertices, 950 edges>
]]></Log>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="RandomTournament">
<ManSection>
  <Oper Name="RandomTournament" Arg="n"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>n</A> is a non-negative integer, this function returns a random
    tournament with <A>n</A> vertices. See <Ref Prop="IsTournament"/>. <P/>
    <Log><![CDATA[
gap> RandomTournament(10);
<digraph with 10 vertices, 45 edges>
]]></Log>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="ChainDigraph">
<ManSection>
  <Oper Name="ChainDigraph" Arg="n"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>n</A> is a positive integer, this function returns a chain 
    with <A>n</A> vertices and <A>n</A><C> - 1</C> edges.
    Specifically,
    for each vertex <C>i</C> (with <M>i &lt; n</M>), there is a directed 
    edge with source <C>i</C> and range <C>i + 1</C>. <P/>
    
    The <Ref Oper="DigraphReflexiveTransitiveClosure"/> of a chain represents a
    total order.<P/>
    <Log><![CDATA[
gap> ChainDigraph(42);
<digraph with 42 vertices, 41 edges>
]]></Log>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="CompleteDigraph">
<ManSection>
  <Oper Name="CompleteDigraph" Arg="n"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>n</A> is a non-negative integer, this function returns the complete 
    digraph with <A>n</A> vertices. See <Ref Prop="IsCompleteDigraph"/>. <P/>
    <Log><![CDATA[
gap> CompleteDigraph(20);
<digraph with 20 vertices, 380 edges>
]]></Log>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="CompleteBipartiteDigraph">
<ManSection>
  <Oper Name="CompleteBipartiteDigraph" Arg="m, n"/>
  <Returns>A digraph.</Returns>
  <Description>
    A complete bipartite digraph is a digraph whose vertices
    can be partitioned into two non-empty vertex sets, such there exist
    a unique edge with source <C>i</C> and range <C>j</C> whenever
    <C>i</C> and <C>j</C> lie in different vertex sets. <P/>

    If <A>m</A> and <A>n</A> are positive integers, this function 
    returns the complete bipartite digraph with vertex sets of size
    <A>m</A> (containing the vertices <C>[1..m]</C>) and size
    <A>n</A> (containing the vertices <C>[(m+1)..n]</C>). 
    <Log><![CDATA[
gap> CompleteBipartiteDigraph(2, 3);
<digraph with 5 vertices, 12 edges>
]]></Log>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="EmptyDigraph">
<ManSection>
  <Oper Name="EmptyDigraph" Arg="n"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>n</A> is a non-negative integer, this function returns the empty 
    digraph with <A>n</A> vertices. An empty digraph is one with no edges. <P/>
    <Log><![CDATA[
gap> EmptyDigraph(20);
<digraph with 20 vertices, 0 edges>
]]></Log>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="CycleDigraph">
<ManSection>
  <Oper Name="CycleDigraph" Arg="n"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>n</A> is a positive integer, this function returns a cycle
    digraph with <A>n</A> vertices and <A>n</A> edges. Specifically,
    for each vertex <C>i</C> (with <M>i &lt; n</M>), there is a directed 
    edge with source <C>i</C> and range <C>i + 1</C>. In addition, there is
    an edge with source <C>n</C> and range <C>1</C>. <P/>
    <Log><![CDATA[
gap> CycleDigraph(1);
<digraph with 1 vertex, 1 edge>
gap> CycleDigraph(123);
<digraph with 123 vertices, 123 edges>
]]></Log>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="ReducedDigraph">
<ManSection>
  <Oper Name="ReducedDigraph" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    This function returns a digraph isomorphic to the argument <A>digraph</A>
    with all its unconnected vertices removed.  The vertex labels and edge
    labels of the graph are preserved, so that a vertex in the new digraph can
    be matched to the corresponding vertex in the old digraph.<P/>
    <Log><![CDATA[
gap> d := Digraph([ [1,2], [], [], [1,4], [] ]);
<digraph with 5 vertices, 4 edges>
gap> r := ReducedDigraph(d);
<digraph with 3 vertices, 4 edges>
gap> OutNeighbours(r);
[ [ 1, 3 ], [ 1, 2 ], [  ] ]
gap> DigraphEdges(r); DigraphEdges(d);
[ [ 1, 1 ], [ 1, 3 ], [ 2, 1 ], [ 2, 2 ] ]
[ [ 1, 1 ], [ 1, 2 ], [ 4, 1 ], [ 4, 4 ] ]
gap> DigraphVertexLabel(r,3);
2
gap> DigraphVertexLabel(r,2);
4
]]></Log>
  </Description>
</ManSection>
<#/GAPDoc>
